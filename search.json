[{"title":"虚拟内存管理：页置换算法","url":"http://muo123.gitee.io/2021/06/24/demandingPage/","content":"虚拟内存管理：页置换算法（FIFO/LRU/Clock）一、内容：虚拟内存管理\n编写一个 C 程序模拟实现请求页面置换算法包括FIFO、LRU (stack and matrix implementation)、Second chance，并设计输入用例验证结果。\n\n二、原理\nFIFO 页置换\n\n\nFIFO 页置换算法为每个记录着该页调入内存的时间。当必须置换一页时，将选择最旧的页。注意并不需要记录调入一页的确切时间。可以创建一个FIFO 队列来管理内存中的所有页。队列中的首页将被置换。当需要调入页时，将它加到队列的尾部\n\n\nLRU 页置换\n\n\nLRU 置换为每个页关联该页上次使用的时间。当必须置换一页时，LRU 选择最长时间没有使用的页。这种策略为向后看最优页置换算法。\n\n\n二次机会算法\n\n\n二次机会置换的基本算法是 FIFO 置换算法。当要选择一个页时，检查其引用位。如果其值为零，那么就置换该页。如果引用位为一，那么就给该页第二次机会，并选择下一个 FIFO 页。当一个页获得第二次机会时，其引用位清零，且其到达时间设为当前时间。因此，获得第二次机会的页在所有其他页置换之前，是不会被置换的，另外，如果一个页经常使用以致其引用位总是被设置，那么它就不会被置换。\n\n三、代码实现2.1、FIFO 页置换策略a、FIFO第一种实现方案：buffer首先定义FIFO策略的缓冲区如下：#define BUFFER_SIZE 3   //FIFO 策略的缓冲区大小\n\ntypedef struct BUFFER &#123; //FIFO策略的缓冲区\n    int page;   //页号\n    int count;  //用于判断页面最先到达的计数器：越先到达的页面 count 越大\n    int valid;  //判断页面有效的位：1-有效，0-无效\n&#125; BUFFER;缓冲区单元包含储存的页page、记录页面到达时间的计数器count、判断当前页是否有效的标志valid\n之后定义缓冲区的操作函数：\n\nbuffer_init 初始化缓冲区\nbuffer_print 打印缓冲区//FIFO缓冲区的初始化函数\nvoid buffer_init(BUFFER *buffer) &#123;  \n    memset(buffer, 0, sizeof(BUFFER)  * BUFFER_SIZE);\n&#125;\n\n//FIFO缓冲区的打印函数：page count valid\nvoid buffer_print(const BUFFER *buffer) &#123;   \n    printf(\"------------------\\n\");\n    printf(\"Page  Count  Valid\\n\");\n    for(int i = 0; i &lt; BUFFER_SIZE; i++) &#123;\n        printf(\"%-7d %-7d %-7d\\n\", buffer[i].page, buffer[i].count, buffer[i].valid);\n    &#125;\n    printf(\"------------------\\n\");\n&#125;\n\n\n之后根据FIFO策略编写代码：\n定义相关变量：命中的标志hit、缓冲区空位的标志empty、记录最大 count 值的临时变量count、记录最小到达页的下标oldest、记录缺页数的变量page_fault以及将要使用到的缓冲区buffer。int hit;                //命中的标志\nint empty;              //缓冲区空位的标志\nint count;              //记录最大 count 值的临时变量\nint oldest;             //记录最小到达页的下标\nint page_fault = 0;     //缺页数\nBUFFER buffer[BUFFER_SIZE];\n\nbuffer_init(buffer);    //缓冲区初始化\nFIFO策略实现如下：for(int i = 0; i &lt; strlen(string); i++) &#123;   //string 是输入字符串\n    if(string[i] == ' ') continue;          //如果当前输入为空格就跳过\n\n    hit = 0;    //初始化相关变量\n    empty = 0;  \n    count = 0;  \n\n    for(int j = 0; j &lt; BUFFER_SIZE; j++) &#123;  //判断当前页是否在缓冲区内，如果存在就将 hit 置位\n        if(buffer[j].page == string[i] - '0' &amp;&amp; buffer[j].valid) &#123;\n            hit = 1;\n            break;\n        &#125;\n    &#125;\n\n    if(!hit) &#123;  //如果没有命中\n        for(int k = 0; k &lt; BUFFER_SIZE; k++) &#123;  \n            if(!buffer[k].valid) &#123;          //如果当前缓冲区有空位，就填入新页\n                empty = 1;\n                oldest = k;\n                break;\n            &#125;\n        &#125;\n\n        for(int k = 0; !empty &amp;&amp; k &lt; BUFFER_SIZE; k++) &#123;\n            if(buffer[k].count > count) &#123;   //如果缓冲区已满，选择最大 count 值的页进行置换\n                count = buffer[k].count;\n                oldest = k;\n            &#125;\n        &#125;\n\n        buffer[oldest].page = string[i] - '0';  //页面导入、有效位置位、count值赋值\n        buffer[oldest].valid = 1;\n        buffer[oldest].count = MAX - i;\n        \n        page_fault ++;  //没有命中，缺页数加一\n    &#125;\n    // buffer_print(buffer);   //每个页号（string[i]）到达后的结果\n&#125;string为输入字符串，我们需要先跳过无效的空格输入，再进行页置换，具体算法：\n\n第一步，判断输入的页是否在缓冲区内，如果存在，说明页被命中，继续下一次输入页判定；否则，转到第二步\n第二步，页未命中，说明发生缺页（缺页数加一）。如果当前缓冲区内还有未填满的单元，就将新页填入；如果缓冲区已满，选择到达最早的页，即 count 值最大的页进行置换\n第三步，循环第一、二步直至输入终止\n\n测试用例：\n测试结果如下：\nb、FIFO第二种实现方案：queue第一种方案中的FIFO策略实现部分虽然达到预期效果，但显得非常冗杂，且实现方式未采用队列，下面使用队列方式进行重新实现\n首先定义队列结构：#define QUEUE_SIZE 3    //FIFO 策略队列的缓冲区大小\n\ntypedef struct QUEUE &#123;  //队列\n    int front;              //队列首指针\n    int rear;               //队列尾指针\n    int size;               //队列大小\n    int buffer[QUEUE_SIZE]; //队列的缓冲区\n&#125; QUEUE;队列包含队首指针front、队尾指针rear、队列大小size和用来储存页的队列缓冲区buffer。\n之后完成队列操作函数的定义：\n\nqueue_init    队列初始化函数\nqueue_empty   队列判空函数\nqueue_full    队列判满函数\nenqueue      入队函数\ndequeue       出队函数\nqueue_find   队列查找函数\nqueue_print   队列打印函数\n\n相关函数实现如下：//队列的初始化函数\nvoid queue_init(QUEUE *queue) &#123;\n    queue->front = queue->rear = queue->size = 0;\n    for(int i = 0; i &lt; QUEUE_SIZE; i++) &#123;\n        queue->buffer[i] = -1;\n    &#125;\n&#125;\n\n//判断队列为空的函数\nint queue_empty(const QUEUE queue) &#123;\n    return queue.size == 0;\n&#125;\n\n//判断队列为满的函数\nint queue_full(const QUEUE queue) &#123;\n    return queue.size == QUEUE_SIZE;\n&#125;\n\n//入队函数\nint enqueue(QUEUE *queue, int e) &#123;\n    if(queue_full(*queue)) return 0;\n\n    queue->buffer[queue->rear] = e;\n    queue->rear = (queue->rear + 1) % QUEUE_SIZE;\n    queue->size ++;\n    return 1;\n&#125;\n\n//出队函数\nint dequeue(QUEUE *queue, int *e) &#123;\n    if(queue_empty(*queue)) return 0;\n\n    *e = queue->buffer[queue->front];\n    queue->front = (queue->front + 1) % QUEUE_SIZE;\n    queue->size --;\n    return 1;\n&#125;\n\n//队列的寻找指定数值的函数\nint queue_find(const QUEUE queue, int e) &#123;\n    for(int i = 0; i &lt; QUEUE_SIZE; i++) &#123;\n        if(queue.buffer[i] == e) return 1;\n    &#125;\n    return 0;\n&#125;\n\n//队列的打印函数\nvoid queue_print(const QUEUE queue) &#123;\n    printf(\"--------------\\n\");\n    for(int i = 0; i &lt; QUEUE_SIZE; i++) &#123;\n        printf(\"buffer[%d]: %d\\n\", i, queue.buffer[i]);\n    &#125;\n    printf(\"--------------\\n\");\n&#125;\n完成队列的相关 API 后，FIFO策略实现如下：//FIFO 策略\nvoid FIFO(char *string) &#123;\n    QUEUE queue;        \n    int page_fault = 0; //记录缺页数的变量\n\n    queue_init(&amp;queue);     //初始化队列\n\n    printf(\"\\nFIFO >> reference string:\\n%s\\n\", string);\n\n    for(int i = 0; i &lt; strlen(string); i++) &#123;   //string 是输入字符串\n        if(string[i] == ' ') continue;          //如果当前输入为空格就跳过\n\n        if(!queue_find(queue, string[i] - '0')) &#123;   //如果当前队列不存在输入页\n            if(!queue_full(queue)) &#123;                    //如果队列未满\n                enqueue(&amp;queue, string[i] - '0');           //将新页填入队列\n            &#125; else &#123;                                    //如果队列已满\n                queue.buffer[queue.front] = string[i] - '0';    //将队首的页置换\n                queue.front = (queue.front + 1) % QUEUE_SIZE;   //队首和队尾向前推进\n                queue.rear = (queue.rear + 1) % QUEUE_SIZE;\n            &#125;\n            page_fault++;   //缺页数加一\n        &#125;\n        // queue_print(queue);  //每个页号（string[i]）到达后的结果\n    &#125;\n    printf(\"FIFO >> Final Result:\\n\");\n    queue_print(queue);\n    printf(\"FIFO >> Page Faults = %d\\n\", page_fault);\n&#125;整体逻辑与第一种实现方案大致相同，但整体有所简化，具体流程如注释\n测试用例：\n测试结果如下：\n2.2、LRU 页置换策略a、LRU第一种实现方案：stack首先对栈结构体进行定义：#define STACK_SIZE 3    //LRU 策略栈的缓冲区大小\n\ntypedef struct STACK &#123;  //栈\n    int top;                    //栈顶指针\n    int buffer[STACK_SIZE];     //栈的缓冲区\n&#125; STACK;结构体中包含两个成员变量：栈顶指针top以及用来储存页的缓冲区buffer\n接下来完成栈的操作函数：\n\nstack_init 栈的初始化函数\nstack_prin 栈的打印函数\nstack_empt 判断栈空\nstack_full 判断栈满\nstack_pull 入栈函数\nstack_pop 出栈函数\nstack_find 栈的查找函数\nstack_move 栈的移动函数\n\n具体实现如下：//栈的初始化函数\nvoid stack_init(STACK *stack) &#123;\n    stack->top = 0;\n    for(int i = 0; i &lt; STACK_SIZE; i++) stack->buffer[i] = -1;\n&#125; \n\n//栈的打印函数\nvoid stack_print(const STACK stack) &#123;\n    printf(\"----------\\n\");\n    for(int i = 0; i &lt; STACK_SIZE; i++) &#123;\n        printf(\"buffer-%d: %d\\n\", i, stack.buffer[i]);\n    &#125;\n    printf(\"----------\\n\");\n&#125;\n\n//判断栈空的函数\nint stack_empty(const STACK stack) &#123;\n    return stack.top == 0;\n&#125;\n\n//判断栈满的函数\nint stack_full(const STACK stack) &#123;\n    return stack.top == STACK_SIZE;\n&#125;\n\n//入栈函数\nint stack_push(STACK *stack, int e) &#123;\n    if(stack_full(*stack)) return 0;\n\n    stack->buffer[stack->top++] = e;  \n    return 1;  \n&#125;\n\n//出栈函数\nint stack_pop(STACK *stack, int *e) &#123;\n    if(stack_empty(*stack)) return 0;\n\n    *e = stack->buffer[stack->top--];\n    return 1;\n&#125;\n\n//栈的寻找指定数值的函数\nint stack_find(const STACK stack, int e) &#123;\n    for(int i = 0; i &lt; stack.top; i++) &#123;\n        if(stack.buffer[i] == e) return i;\n    &#125;\n    return -1;\n&#125;\n\n//栈的移动函数：pos 后面的数全部向前移动一位，并将 e 放到栈顶\nvoid stack_move(STACK *stack, int pos, int e) &#123;\n    for(int i = pos; i &lt; stack->top; i++) &#123;\n        stack->buffer[i] = stack->buffer[i+1];\n    &#125;\n    stack->buffer[stack->top - 1] = e;\n&#125;以上函数需要注意的是stack_move，属于自定义的额外操作函数，它的作用是将指定位置的数都向前移动一位，并将指定数值赋压入栈顶。\n之后根据 LRU 策略完成栈实现：void LRU_stack(char *string) &#123;\n    int hit_num;    //记录命中页的下标\n    STACK stack;    \n    int page_fault = 0;\n\n    stack_init(&amp;stack);     //初始化栈\n\n    printf(\"\\nLRU stack >> reference string:\\n%s\\n\", string);\n\n    for(int i = 0; i &lt; strlen(string); i++) &#123;\n        if(string[i] == ' ') continue;\n\n        hit_num = stack_find(stack, string[i] - '0');   //搜索栈中是否存在指定页\n        \n        if(hit_num >= 0) &#123;                   //如果存在\n            int temp = stack.buffer[hit_num];   //将该页放到栈顶\n            stack_move(&amp;stack, hit_num, temp);\n        &#125; else &#123;                             //如果不存在\n            if(!stack_full(stack)) &#123;                //如果栈已满\n                stack_push(&amp;stack, string[i] - '0');    //将该页放到栈底\n            &#125; else &#123;                                //否则\n                stack_move(&amp;stack, 0, string[i] - '0'); //将该页放到栈顶\n            &#125;\n            page_fault++;\n        &#125;\n        // stack_print(stack);   //每个页号（string[i]）到达后的结果\n    &#125;\n    printf(\"LRU stack >> final result:\\n\");\n    stack_print(stack);\n    printf(\"LRU stack >> page faults = %d\\n\", page_fault);\n&#125;栈实现的 LRU 策略算法流程如下：\n\n第一步，搜索当前栈中是否存在相关页，如果存在，就将该页放到栈顶；否则转到第二步\n第二步，栈中不存在相关页，说明发生缺页。如果栈中还有位置，就将该页入栈；不然，就将该页与栈底的页进行置换，并将该页放到栈顶\n第三步，重复第一、二步直至输入终止\n\n测试用例：\n测试结果：\nb、LRU第二种实现方案：matrix对矩阵结构体进行定义：#define MATRIX_SIZE 4   //LRU 策略矩阵缓冲区大小\n#define MAX_N 10        //LRU 策略矩阵的大小\n\ntypedef struct MATRIX &#123; //矩阵\n    int size;                   //当前页的数量\n    int buffer[MATRIX_SIZE];    //矩阵缓冲区\n    int m[MAX_N][MAX_N];        //用于置换页的矩阵\n&#125; MATRIX;结构体中包含存储页的缓冲区buffer，记录当前页数量的变量size以及用于计算最不常用页的辅助矩阵m\n矩阵的操作函数如下：\n\nmatrix_init 矩阵的初始化函数\nmatrix_print 矩阵的打印函数\nmatrix_find 矩阵的查找函数\nmatrix_smallest_row 矩阵的寻找最小行函数\nmatrix_set 矩阵的置位函数\n\n具体实现如下所示：//矩阵的初始化函数\nvoid matrix_init(MATRIX *matrix) &#123;\n    matrix->size = 0;\n    for(int i = 0; i &lt; MATRIX_SIZE; i++) matrix->buffer[i] = -1;\n    for(int i = 0; i &lt; MAX_N; i++) &#123;\n        for(int j = 0; j &lt; MAX_N; j++) matrix->m[i][j] = 0;\n    &#125;\n&#125;\n\n\n//矩阵的打印函数\nvoid matrix_print(const MATRIX matrix) &#123;\n    printf(\"--------------\\n\");\n    printf(\"page  matrix\\n\");\n    for(int i = 0; i &lt; MATRIX_SIZE; i++) &#123;\n        int page = matrix.buffer[i] == -1 ? i : matrix.buffer[i];\n        printf(\"%-6d\", matrix.buffer[i]);\n        for(int j = 0; j &lt; MAX_N; j++) &#123;\n            printf(\"%d \", matrix.m[page][j]);\n        &#125;\n        printf(\"\\n\");\n    &#125;\n    printf(\"--------------\\n\");\n&#125;\n\n//矩阵的查找函数：返回存储 page 的 buffer 下标值\nint matrix_find(const MATRIX matrix, int page) &#123;\n    for(int i = 0; i &lt; matrix.size; i++) &#123;\n        if(matrix.buffer[i] == page) return i;\n    &#125;\n    return -1;\n&#125;\n\n//矩阵的寻找最小行函数：返回矩阵中最小行\nint matrix_smallest_row(const MATRIX matrix) &#123;\n    int smallest = MAX_N;\n    int smallest_row = MAX_N;\n\n    for(int j = 0; j &lt; MATRIX_SIZE; j++) &#123;\n        int temp = 0;\n        int page = matrix.buffer[j];\n        for(int k = 0; k &lt; MAX_N; k++) &#123;\n            temp += matrix.m[page][k];\n        &#125;\n        if(smallest > temp) &#123;\n            smallest = temp;\n            smallest_row = j;\n        &#125;\n    &#125;\n    return smallest_row;\n&#125;\n\n//矩阵的设置数值函数：将 page 行置位，page 列清零\nvoid matrix_set(MATRIX *matrix, int page) &#123;\n    for(int j = 0; j &lt; MAX_N; j++) &#123;\n        matrix->m[page][j] = 1;\n        matrix->m[j][page] = 0;\n    &#125;\n&#125;需要进行解释的是矩阵的寻找最小行函数和设置数值函数：matrix_smallest_row函数遍历矩阵寻找最小行，并将最小行的行号返回；而matrix_set是将指定的行元素全部置为 1，将指定的列元素全部置为 0.\nLRU 策略的矩阵实现结果如下：//LRU 策略的矩阵实现\nvoid LRU_matrix(char *string) &#123;\n    int smallest_row;   //记录最小行的变量\n    MATRIX matrix;\n    int page_fault = 0;\n    \n    matrix_init(&amp;matrix);\n\n    printf(\"\\nLRU matrix >> reference string:\\n%s\\n\", string);\n\n    for(int i = 0; i &lt; strlen(string); i++) &#123;\n        if(string[i] == ' ') continue;\n\n        int page = string[i] - '0';\n\n        if(matrix_find(matrix, page) == -1) &#123;       //如果在缓冲区中没有找到对应页\n            if(matrix.size != MATRIX_SIZE) &#123;            //如果当前缓冲区未满\n                matrix.buffer[matrix.size++] = page;        //将新页加入\n            &#125; else &#123;                                    //否则\n                smallest_row = matrix_smallest_row(matrix); //选择最小行的页进行置换\n                matrix.buffer[matrix_find(matrix, smallest_row)] = page;\n            &#125;\n            page_fault++;   \n        &#125;\n        matrix_set(&amp;matrix, page);  //设置 page 的行值和列值\n        // matrix_print(matrix);   //每个页号（string[i]）到达后的结果\n    &#125;\n    printf(\"LRU matrix >> final result:\\n\");\n    matrix_print(matrix);\n    printf(\"LRU matrix >> page fault = %d\\n\", page_fault);\n&#125;无论是否找到页，都需要将矩阵的指定行和指定列进行置位。\n如果没有找到输入的页，根据当前缓冲区是否已满，来决定是否直接插入新页；如果缓冲区已满，就将矩阵中行值最小的页进行置换。\n测试用例： 0, 1, 2, 3, 2, 1, 0, 3, 2, 3.\n测试结果如下：\n\n2.3、Second Chance 页置换策略：Clock第二次机会页置换算法使用循环队列实现，定义的 Clock 结构体如下所示：\n#define CLOCK_SIZE 3    //Clock 策略的缓冲区大小\n#define MAX 99          //所定义的最大数\n\ntypedef struct CLOCK &#123;  //时钟\n    int pointer;    //时钟的指针\n    int used[CLOCK_SIZE];    //判断当前位被使用的标志\n    int buffer[CLOCK_SIZE];  //储存页的缓冲区\n&#125; CLOCK;\n包含时钟的指针pointer，使用标志数组used以及储存页的缓冲区buffer\nclock 的操作函数有：\n\nclock_init clock 的初始化函数\nclock_print clock 的打印函数\nclock_sum clock 的求和函数\n\n实现结果如下：//clock 的初始化函数\nvoid clock_init(CLOCK *clock) &#123;\n    clock->pointer = 0;\n    for(int i = 0; i &lt; CLOCK_SIZE; i++) &#123;\n        clock->buffer[i] = -1;\n        clock->used[i] = 0;\n    &#125;\n&#125;   \n\n//clock 的打印函数：buffer page used（块索引 页号 页使用标志）\nvoid clock_print(const CLOCK clock) &#123;\n    printf(\"----------------\\n\");\n    printf(\"Buffer Page Used\\n\");\n    for(int i = 0; i &lt; CLOCK_SIZE; i++) &#123;\n        printf(\"%-6d %-6d %-6d\\n\", i, clock.buffer[i], clock.used[i]);\n    &#125;\n    printf(\"----------------\\n\");\n&#125;\n\n//clock 的求和函数：计算使用位 used 的和\nint clock_sum(const CLOCK clock) &#123;\n    int sum = 0;\n    for(int i = 0; i &lt; CLOCK_SIZE; i++) &#123;\n        sum += clock.used[i];\n    &#125;\n    return sum;\n&#125;\n根据 Second chance 策略实现算法如下：//Clock 策略\nvoid Clock(char *string) &#123;\n    CLOCK clock;\n    int hit;\n    int circular_flag = 0;  //时钟循环的标志\n    int page_fault = 0;\n\n    clock_init(&amp;clock);     //初始化clock\n\n    printf(\"\\nClock >> reference string:\\n%s\\n\", string);\n\n    for(int i = 0; i &lt; strlen(string); i++) &#123;\n        if(string[i] == ' ') continue;\n\n        while(1) &#123;\n            hit = 0;\n\n            while (circular_flag > 0) &#123; //如果循环标志大于零，说明当前还有未访问到的页面，可以继续搜索\n                if(clock.buffer[clock.pointer] == string[i] - '0') &#123; //如果搜索到指定页\n                    hit = 1;                                            //页命中\n                    clock.used[clock.pointer] = 1;                      //页被使用\n                    clock.pointer = 0;                                  //时钟指针置零\n\n                    circular_flag = clock_sum(clock);   //更新循环标志\n                    break;\n                &#125; \n                                                        //如果没有搜索到\n                clock.used[clock.pointer] = 0;                      //页未被使用\n                clock.pointer = (clock.pointer + 1) % CLOCK_SIZE;   //时钟指针向后拨动一位\n\n                circular_flag = clock_sum(clock);       //更新循环标志\n            &#125;\n\n            if(hit) break;  //如果命中就退出循环，否则说明缺页\n\n            page_fault++;\n\n            clock.buffer[clock.pointer] = string[i] - '0';      //填入当前指针指向页\n            clock.used[clock.pointer] = 1;                      //页被使用\n            clock.pointer = (clock.pointer + 1) % CLOCK_SIZE;   //时钟指针向后拨动一位\n\n            circular_flag = clock_sum(clock);           //更新循环标志\n            break;\n        &#125;\n        clock_print(clock);   //每个页号（string[i]）到达后的结果\n    &#125;\n    printf(\"Clock >> final result:\\n\");\n    clock_print(clock);\n    printf(\"Clock >> page faults = %d\\n\", page_fault);\n&#125;\n算法中需要注意的是循环标志circular_flag，用于指示当前是否访问所有页：大于 0，说明有未被访问的页。\ncircularflag = \\sum_{0 ≤ i ≤ clocksize} used[i]算法过程如下：\n\n第一步，进行页查找，如果搜索到指定页，就将标志位 used[i]置位，说明页被使用，并将时针清零；否则，就将访问到的页置零，同时时针顺时针拨动。假如当前页中不存在指定页，就转到第二步\n第二步，说明页未被命中，将当前指针所指的页进行置换，并将 used[i] 置位，同时时针继续向后拨动\n第三步，循环第一、二步直至输入终止\n\n算法需要实时更新循环标志，防止时针逻辑出错。循环标志主要用来判断是否需要进行页置换，循环标志等于 0 的时候，说明此时时针已经遍历所有页，且未找到指定页，那么就需要将时针指向的页与指定页进行交换。\n测试用例：\n\n测试结果：\n\n2.4 策略比较测试用例：\n\n测试结果： \n\n","categories":["Program"],"tags":["C","页置换"]},{"title":"CPU 调度算法","url":"http://muo123.gitee.io/2021/06/23/peterson/","content":"CPU 调度算法(FCFS / SJF / Priority)一、内容：CPU 调度。\n尝试基于 POSIX API 设计一个简单调度器（不考虑资源竞争问题）：\n创建一些 Pthread 线程任务，建立一个管理链队列，结点内容起码包括到达时间、WCT、优先级、调度状态（运行、就绪、阻塞）等调度参数；\n每个任务有一个调度信号量，任务启动后在其调度信号量上执行 wait；\n调度器按照调度策略对处于运行态的任务（如果有的话）的调度信号量执行 wait，并选取适当任务的调度信号量执行 signal；\n实现简单调度策略：FCFS、SJB、Priority。分别计算任务平均等待时间。\n\n\n\n\n二、原理\nFCFS\n\n\n最简单的CPU调度算法是先到先服务算法（first-come，first-served，FCFS）。采用这种方案，先请求CPU的进程被首先分配到CPU。FCFS 策略可以用 FIFO 队列来容易实现。当一个进程进入到就绪队列，其 PCB 被链接到队列的尾部。当 CPU 空闲时，CPU被分配给位于队列头的进程。接着，该运行进程从队列中被删除。FCFS 调度的代码编写简单且容易理解。不过，采用 FCFS 策略的平均等待时间通常相当长。\n\n\nSJF\n\n\n最短作业优先调度算法（shortest-job-first，SJF），这一算法将每个进程与其下一个CPU区间段相关联。当 CPU 为可用时，它会赋给具有最短后续 CPU 区间的进程。如果两个进程具有相同长度的 CPU 区间，那么可以使用 FCFS 调度来处理。注意一个更为适当的表示是最短的下一个 CPU 区间，这是因为调度的完成是通过检查进程的下一个 CPU 区间的长度，而不是其总长度。\n\n\nPriority\n\n\nSJF算法可作为通用优先级调度算法（priority-scheduling algorithm）的一个特例。每个进程都有一个优先权与其关联，具有最高优先权的进程会被分配到 CPU。具有相同优先权的进程按 FCFS 顺序调度。SJF 作为优先权算法，其优先权为下一个 CPU区间的倒数。CPU 区间越大，则优先权越小；反之亦然。注意这里按照高优先权和低优先权来讨论调度。优先权通常为固定区间的数字，如 0 到 7，或 0 到 4095。\n\n三、设计首先考虑线程任务需要包含哪些成员变量，例如任务的到达时间、CPU执行时间、任务的优先级以及任务的调度状态等。之后，考虑任务调度中需要用到的成员函数：\n\nFCFS调度策略：FCFS_scheduling\nSJF调度策略：SJF_scheduling\nPriority调度策略：Priority_scheduling\n\n注意：所实现的调度策略都是采用非抢占式调度模式\n具体代码实现如下所示：#define MAX_N 5\t\t\t//CPU调度中的总任务数\n#define MAX_PRIORITY 7\t//最大优先级\n#define IFINITE 999\t  \t//无穷大数首先进行宏定义，如CPU调度中的最大任务数、优先级调度的最大优先级以及程序中所使用的无穷大\ntypedef enum STATUS &#123;\t//任务的调度状态：就绪、运行、阻塞、结束\n\tREADY, RUNNING, BLOCKED, FINISHED\n&#125;STATUS;\n使用枚举类型列举任务的调度状态：就绪、运行、阻塞、结束\nTASK tasks[MAX_N];\t\t//全局任务静态链表\nsem_t schedule_sem;\t\t//调度器信号量\nint chart[MAX_N][IFINITE] = &#123;0&#125;;\t//甘特图数组\nint current_time;\t\t//CPU当前运行时间\n定义相关全局变量，tasks作为任务的静态链表，用于任务调度；schedule_sem作为调度器信号量，当任务完成时，提示调度器选取下一个任务进入运行态；chart是用于储存甘特图的字符数组，每次任务执行时，会记录相关任务执行过程；current_time记录当前CPU的运行时间。\nstatic void *thread_work(void *arg) &#123;\n\tint *numptr = (int *)arg;\t//参数转换\n\tint num = *numptr;\n\n\tprintf(\"thread-%lu is created\\n\", pthread_self());\n\tsem_wait(&amp;tasks[num].sem);\t//在任务到来前执行 wait\n\n\ttasks[num].status = RUNNING;\t//任务开始执行\n\tprintf(\"thread-%lu is working on task-%d\\n\", pthread_self(), num);\n\n\tfor(int i = 0; i &lt; tasks[num].burst_time; i++) &#123;\t//储存当前任务执行过程，用作甘特图图示\n\t\tchart[num][i + current_time] = 1;\n\t&#125;\n\n\ttasks[num].status = FINISHED;\t//任务结束运行\n\tprintf(\"thread-%lu has finished task-%d\\n\", pthread_self(), num);\n\n\tsem_post(&amp;schedule_sem);\t//通知调度器可以调度新的任务\n\tpthread_exit(0);\n&#125;\n线程函数在任务启动后，在任务信号量sem上执行等待，直至调度器开始调度任务才开始运行。同时，在任务执行时，记录任务执行过程，供之后甘特图展示。在任务完成后，任务的调度状态修改为结束态，通知调度器可以调度新任务执行，最后退出任务。\n//函数用于初始化任务列表\nvoid tasks_init() &#123;\n\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\n\t\ttasks[i].arrival_time = i * 2;\n\t\ttasks[i].status = BLOCKED;\n\t\tint ret = sem_init(&amp;tasks[i].sem, 0, 0);\n\t\tif(ret == -1) &#123;\n\t\t\tperror(\"tasks:sem_init()\");\n\t\t\texit(1);\n\t\t&#125;\n\t&#125;\n\n\ttasks[0].burst_time = 3;\n\ttasks[1].burst_time = 6;\n\ttasks[2].burst_time = 4;\n\ttasks[3].burst_time = 5;\n\ttasks[4].burst_time = 2;\n\n\ttasks[0].priority = 3;\n\ttasks[1].priority = 7;\n\ttasks[2].priority = 6;\n\ttasks[3].priority = 2;\n\ttasks[4].priority = 4;\n&#125;\n函数tasks_init用于初始化任务列表，初始化的变量有任务到达时间arrival_time、任务状态status、任务信号量sem、任务CPU执行时间burst_time以及当前任务的优先级priority。初始化后的任务列表如下所示：\n\n\n\n\nProcess\nArrival time\nBurst time\nPriority\n\n\n\n\nP0\n0\n3\n3\n\n\nP1\n2\n6\n7 \n\n\nP2\n4\n4\n6\n\n\nP3\n6\n5\n2\n\n\nP4\n8\n2\n4\n\n\n\n\nvoid tasks_print() &#123;\n\tprintf(\"\\n********tasks graph********\\n\");\n\tprintf(\"Task Arrival Burst Priority\\n\");\n\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\n\t\tprintf(\"%d\\t%d\\t%d\\t%d\\n\", i, tasks[i].arrival_time, tasks[i].burst_time, tasks[i].priority);\n\t&#125;\n\tprintf(\"***************************\\n\\n\");\n&#125;\n函数tasks_print用于打印当前测试的任务队列：任务名 到达时间 执行时间 优先级\nvoid chart_print() &#123;\n\tprintf(\"\\nThe Gantt Chart for the schedule\\n\");\n\tprintf(\"-------------------------------\\n\");\n\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\n\t\tprintf(\"task-%d \", i);\n\t\tfor(int j = 0; j &lt; current_time; j++) &#123;\n\t\t\tif(chart[i][j] == 0) printf(\" \");\n\t\t\telse printf(\"*\");\n\t\t&#125;\n\t\tprintf(\"\\n\");\n\t&#125;\n\tprintf(\"-------------------------------\\n\");\n&#125;\n函数chart_print用于打印任务执行过程的甘特图，演示任务调度时的总体到达情况和执行用时\n1、FCFS 策略//FCFS-先到先服务调度策略\nvoid FCFS_scheduling()&#123;\n\tprintf(\"\\n-----FCFS scheduling-----\\n\");\n\n\tint total_wait_time = 0;\t//任务等待的总用时\n\tint total_burst_time = 0;\t//任务执行总用时\n\tint task_num = MAX_N;\t\t//需要执行的任务数\n\tint first_task = 0;\t\t\t//第一个到达的任务\n\tint arrive_task = 0;\t\t//到达的任务\n\tint arrive_time;\t\t\t//任务到达的时间\n\tcurrent_time = 0;\t\t\t//CPU当前运行时间\n\n\twhile(task_num >= 0) &#123;\t\t//当任务数大于等于 0 时，进行CPU调度\n\t\tsem_wait(&amp;schedule_sem);\t//调度器等待任务完成\n\t\tcurrent_time = total_burst_time;\t//当前运行时间等于任务执行总用时\n\n\t\tif(task_num == 0) break;\t//如果任务数为 0，即任务全部执行结束，就退出调度\n\n\t\tif(first_task == arrive_task) &#123;\t\t//第一个任务到达时，直接进入内核运行\n\t\t\ttasks[first_task].status = READY;\t//第一个任务调度状态变为就绪态\n\t\t\tarrive_task == first_task;\t//第一个任务到达\n\t\t&#125; else &#123;\n\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\t//比较当前运行时间和任务到达时间，如果任务已到达，就转为就绪态\n\t\t\t\tif(tasks[i].status == BLOCKED &amp;&amp; total_burst_time > tasks[i].arrival_time) &#123;\n\t\t\t\t\ttasks[i].status = READY;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\tint flag = 0;\t\t//查询当前就绪队列中是否存在任务\n\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\n\t\t\t\tif(tasks[i].status == READY) &#123;\n\t\t\t\t\tflag = 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tif(flag == 0) &#123;\t\t//如果就绪队列中没有任务，就选择下一个阻塞任务进入就绪队列\n\t\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\n\t\t\t\t\tif(tasks[i].status == BLOCKED) &#123;\n\t\t\t\t\t\ttasks[i].status = READY;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\tarrive_time = IFINITE;\n\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\t//选择最先到达的任务\n\t\t\t\tif(tasks[i].status == READY &amp;&amp; arrive_time > tasks[i].arrival_time) &#123;\n\t\t\t\t\tarrive_time = tasks[i].arrival_time;\n\t\t\t\t\tarrive_task = i;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tprintf(\"\\ntask-%d arrived\\n\", arrive_task);\n\t\tsem_post(&amp;tasks[arrive_task].sem);\t\t//通知线程执行任务\n\n\t\tif(total_burst_time > tasks[arrive_task].arrival_time) &#123;\t//计算任务等待时间\n\t\t\ttotal_wait_time += total_burst_time - tasks[arrive_task].arrival_time;\n\t\t\ttotal_burst_time += tasks[arrive_task].burst_time;\t//更新CPU总执行时间\n\t\t&#125; else &#123;\n\t\t\ttotal_burst_time = tasks[arrive_task].burst_time + tasks[arrive_task].arrival_time;\n\t\t&#125;\n\n\t\tarrive_task = IFINITE;\n\n\t\ttask_num--;\t\t//当前任务数量减一\n\t&#125;\n\tsleep(1);\n\n\tchart_print();\t//输出调度过程的甘特图\n\tprintf(\"\\nFCFS: total waiting time = %d\\n\", total_wait_time);\n\tprintf(\"FCFS: avarage waiting time = %lf\\n\", (float)total_wait_time / MAX_N);\n\tprintf(\"\\n-----FCFS scheduling-----\\n\");\n&#125;\n函数FCFS_scheduling模拟 FCFS 调度策略。当任务数大于 0 时，即任务链表中的任务不为空时，调度器才进行调度，当任务链表为空时，退出调度过程。\n调度器首先对调度器信号量schedule_sem执行等待，只有当上一个任务完成后，调度器才能调度下一个任务。如果当前任务数为 0，说明任务队列中的任务已经全部完成调度，于是退出调度器。否则，执行下一轮调度。\n当第一个任务到达时，直接进入内核执行，而无需进行等待。如果第一个任务执行时，有其他任务到达，就将到达的任务调整到就绪队列；如果没有其他任务到达，就选择下一个阻塞任务进入就绪队列。等到内核中的任务结束，选择就绪队列中最先到达的任务进行调度。\n等到所有任务调度结束，就打印调度过程的甘特图，并输出调度时的平均等待时间\n2、SJF 策略//SJF-最短作业优先调度策略\nvoid SJF_scheduling() &#123;\n\tprintf(\"\\n-----SJF scheduling-----\\n\");\n\n\tint total_wait_time = 0;\n\tint total_burst_time = 0;\n\tint task_num = MAX_N;\n\tint first_task = 0;\n\tint shortest_task = 0;\n\tint shortest_time;\n\tcurrent_time = 0;\n\n\twhile(task_num >= 0) &#123;\n\t\tsem_wait(&amp;schedule_sem);\n\t\tcurrent_time = total_burst_time;\n\n\t\tif(task_num == 0) break;\n\n\t\tif(first_task == shortest_task) &#123;\t\t//第一个任务到达时，直接进入内核执行\n\t\t\ttasks[first_task].status = READY;\n\t\t\tshortest_task == first_task;\t\n\t\t&#125; else &#123;\n\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\t//将已到达的任务转为就绪态\n\t\t\t\tif(tasks[i].status == BLOCKED &amp;&amp; total_burst_time > tasks[i].arrival_time) &#123;\n\t\t\t\t\ttasks[i].status = READY;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\tint flag = 0;\t\t//查询当前就绪队列中是否存在任务\n\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\n\t\t\t\tif(tasks[i].status == READY) &#123;\n\t\t\t\t\tflag = 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tif(flag == 0) &#123;\t\t//如果就绪队列中没有任务，就选择下一个阻塞任务进入就绪队列\n\t\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\n\t\t\t\t\tif(tasks[i].status == BLOCKED) &#123;\n\t\t\t\t\t\ttasks[i].status = READY;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\tshortest_time = IFINITE;\n\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\t//选择执行时间最短的任务进行运行\n\t\t\t\tif(tasks[i].status == READY &amp;&amp; shortest_time > tasks[i].burst_time) &#123;\n\t\t\t\t\tshortest_time = tasks[i].burst_time;\n\t\t\t\t\tshortest_task = i;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tprintf(\"\\ntask-%d arrived\\n\", shortest_task);\n\t\tsem_post(&amp;tasks[shortest_task].sem);\n\n\t\tif(total_burst_time > tasks[shortest_task].arrival_time) &#123;\n\t\t\ttotal_wait_time += total_burst_time - tasks[shortest_task].arrival_time;\n\t\t\ttotal_burst_time += tasks[shortest_task].burst_time;\n\t\t&#125; else &#123;\n\t\t\ttotal_burst_time = tasks[shortest_task].burst_time + tasks[shortest_task].arrival_time;\n\t\t&#125;\n\n\t\t\n\n\t\tshortest_task = IFINITE;\n\n\t\ttask_num--;\n\t&#125;\n\tsleep(1);\n\tchart_print();\n\tprintf(\"\\nSJF: total waiting time = %d\\n\", total_wait_time);\n\tprintf(\"SJF: avarage waiting time = %lf\\n\", (float)total_wait_time / MAX_N);\n\tprintf(\"\\n-----SJF scheduling-----\\n\");\n\n&#125;\n函数SSJF_scheduling模拟 SJF 调度策略。任务链表中的任务不为空时，调度器才进行调度。调度过程与 FCFS 调度过程类似，不过此时是按照执行时间最短的作业进行调度\n当第一个任务到达时，同样直接进入内核执行，而无需进行等待。如果第一个任务执行时，有其他任务到达，就将到达的任务调整到就绪队列；如果没有其他任务到达，就选择下一个阻塞任务进入就绪队列。\n内核中的任务结束后，选择就绪队列中执行时间最短的任务进入内核执行。\n3、Priority 策略//Priority-优先级调度策略\nvoid Priority_scheduling()&#123;\n\tprintf(\"\\n-----Priority scheduling-----\\n\");\n\n\tint total_wait_time = 0;\n\tint total_burst_time = 0;\n\tint task_num = MAX_N;\n\tint first_task = 0;\n\tint priority_task = 0;\n\tint priority;\n\tcurrent_time = 0;\n\n\twhile(task_num >= 0) &#123;\n\t\tsem_wait(&amp;schedule_sem);\n\t\tcurrent_time = total_burst_time;\n\n\t\tif(task_num == 0) break;\n\n\t\tif(first_task == priority_task) &#123;\t\t//第一个任务到达时，直接进入内核执行\n\t\t\ttasks[first_task].status = READY;\n\t\t\tpriority_task == first_task;\t\n\t\t&#125; else &#123;\n\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\t//将已到达的任务转为就绪态\n\t\t\t\tif(tasks[i].status == BLOCKED &amp;&amp; total_burst_time > tasks[i].arrival_time) &#123;\n\t\t\t\t\ttasks[i].status = READY;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\tint flag = 0;\t\t//查询当前就绪队列中是否存在任务\n\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\n\t\t\t\tif(tasks[i].status == READY) &#123;\n\t\t\t\t\tflag = 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tif(flag == 0) &#123;\t\t//如果就绪队列中没有任务，就选择下一个阻塞任务进入就绪队列\n\t\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\n\t\t\t\t\tif(tasks[i].status == BLOCKED) &#123;\n\t\t\t\t\t\ttasks[i].status = READY;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\tpriority = IFINITE;\n\t\t\tfor(int i = 0; i &lt; MAX_N; i++) &#123;\t//选择最高优先级的任务（数字从小到大，优先级从高到低）\n\t\t\t\tif(tasks[i].status == READY &amp;&amp; priority > tasks[i].priority) &#123;\n\t\t\t\t\tpriority = tasks[i].priority;\n\t\t\t\t\tpriority_task = i;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tprintf(\"\\ntask-%d arrived\\n\", priority_task);\n\t\tsem_post(&amp;tasks[priority_task].sem);\n\n\t\tif(total_burst_time > tasks[priority_task].arrival_time) &#123;\n\t\t\ttotal_wait_time += total_burst_time - tasks[priority_task].arrival_time;\n\t\t\ttotal_burst_time += tasks[priority_task].burst_time;\n\t\t&#125; else &#123;\n\t\t\ttotal_burst_time = tasks[priority_task].burst_time + tasks[priority_task].arrival_time;\n\t\t&#125;\n\n\t\t\n\n\t\tpriority_task = IFINITE;\n\n\t\ttask_num--;\n\t&#125;\n\tsleep(1);\n\tchart_print();\n\tprintf(\"\\nPriority: total waiting time = %d\\n\", total_wait_time);\n\tprintf(\"Priority: avarage waiting time = %lf\\n\", (float)total_wait_time / MAX_N);\n\tprintf(\"\\n-----Priority scheduling-----\\n\");\n&#125;\n函数Priority_scheduling模拟优先级调度策略。SJF 是最短作业优先调度策略，也是隐含的优先级调度策略。在优先级调度策略的调度过程中，调度的标准从最短作业变成了优先级最高的作业，其他内容并无太大差异，这里不进行重复说明。\n下面对 mian 函数内容进行解释：tasks_init();\t//初始化任务列表\ntasks_print();\t//打印当前任务列表首先对任务列表进行初始化，并将任务列表可视化地展示到控制台。\nfor(int i = 0; i &lt; MAX_N; i++) &#123;\t//创建 MAX_N 个线程，分别对应 MAX_N 个任务\n\tret = pthread_create(&amp;ptid[i], NULL, thread_work, (void *)&amp;thread_num[i]);\n\tif(ret == -1) &#123;\n\t\tperror(\"pthread_create()\");\n\t\texit(1);\n\t&#125;\n&#125;\n完成任务列表初始化后，创建MAX_N个线程，供调度器调度。\n//根据命令行参数选择调度策略\nif(argc > 1 &amp;&amp; !strncmp(argv[1], \"sjf\", 3)) SJF_scheduling();\nelse if(argc > 1 &amp;&amp; !strncmp(argv[1], \"pri\", 3)) Priority_scheduling();\nelse FCFS_scheduling();\n通过命令行参数，选择相关调度策略。默认的调度策略是先到先服务 FCFS 策略。\nfor(int i = 0; i &lt; MAX_N; i++) &#123;\t//进行线程回收\n\tret = pthread_join(ptid[i], NULL);\n\tif(ret == -1) &#123;\n\t\tperror(\"pthread_join()\");\n\t\texit(1);\n\t&#125;\n&#125;\n最后对结束运行的线程进行回收\n四、结果分析\nFCFS策略\n\n\n\nSJF 策略\n\n\n\nPriority 策略\n\n\n","categories":["Program"],"tags":["C","Peterson","CPU 调度","Pthread"]},{"title":"将心放在属于自己的时代","url":"http://muo123.gitee.io/2021/04/14/heart&life/","content":"&ensp;&ensp;读书是为了享受他人的思考，同时激发自己的思考。这背后都暗藏着美的激情。我相信，真正热爱思考的人会知道自己的方向。所以说，重要的是你把心放在哪一个时代，而不是把身放在哪一座庙。庙不重要，重要的是你的心，以及你所相信并热爱的一切。”——《心有所往，庙不可言》  \n&ensp;&ensp;用笔记本记录下了这样一段书摘，朴素而又充满真理的表达让我回想起多日未曾触碰的日志文档，也藉此抒发像小山一样堆积起来的情绪。昨日在翻阅过往日志的期间，也思考过寻找恰当的时机，将自己的不太成熟的想法轻轻表露。无论是苦涩的，还是甜蜜的，任何的品味在回忆中都是独特的存在，我希望它们在字里行间保持原来的姿态，肆意挥洒。  \n&ensp;&ensp;许多时候，和别人谈起自己的作为，我都有着特殊的焦虑，这份焦虑可能来自过去，也或许来自未来，也可能就在当下。求学须保持严谨的态度和细心的品质，现在的我却丧失了许多必要的激情，而将精力花费在芜杂的事件簿。每个人或许都有过幻想，能够多面玲珑地处理突如其来的危机，可是时间的单一性让并发处理事件的行为只存在于个人幻想中。区分事件的轻重缓急，一直是我苦恼的难题，在休闲中觅得灵感后，结果却往往是无疾而终。  \n&ensp;&ensp;热爱思考是学习中必要的品质，人无时无刻不在学习，但无收获的重复劳动也一直在进行。思考鲜少追究问题的本质，许多亮点被轻易的放过，这个过程就像在用望远镜观察宇宙中的点点星辰，只知道星辰在发光发亮，却不知道它因何而生，又因何而灭。真正的亮点往往存在于被人们忽视的角落，而非表面的靓丽。本质所支撑的表象，总是带着神秘的迷惑性，“知其所以然，知其非所以然”显得越加必要。  \n&ensp;&ensp;将心放在属于自己的地方，这是寡头的承诺，而自身便是个人思想的寡头。这让我想起言语的艺术性，艺术性在于其可以在可实现和不可实现两种状态自由切换。真正意义上的言不由衷和言语由衷的区分，在于自身付出的代价。也并不是说，付出代价越多便能达到更高的层次，只是，投入必要的激情，付出足够的代价，就像在苦到极致的中药中加入适量的糖，埋头饮下这独特的回甘。    \n&ensp;&ensp;相信自己所热爱的一切，享受他人思考，激发自己的思考，时间开销需要用心管理，请郑重地把心放在属于自己的这个时代。\n","categories":["Idea"],"tags":[]},{"title":"使用 DFS 枚举格雷码","url":"http://muo123.gitee.io/2021/03/23/dfs&gray/","content":"使用DFS枚举格雷码问题：给定正整数$n$，需要输出$2^n$个$n$位01串，且相邻01串之间只允许有一位不相同。$n=2$时的结果：00，01，11，10$n=3$时的结果：000，001，011，010，110，111，101，100    \n思路：由题目描述，可以联想到格雷码，相邻字符串只有1位不同。等长01串，使用二叉树结构储存，通过特定的排列，使得根节点到叶子节点的路径上刚好是所需要的01串,最后通过对二叉树遍历，输出所有可能的结果。每次遍历都需要从根节点到叶子节点，同时记录路径上的01值，可以使用DFS(深度优先搜索)进行遍历。\n算法:#include &lt;stdio.h>\n/*input函数用来控制输入信息，防止输入违法数值*/\nint input(int * n) &#123;\n    scanf(\"%d\", n);\n    if(*n &lt;= 0) &#123;\n        printf(\"illegal input!\\n\");\n        return 0;\n    &#125; \n    return 1;\n&#125;\n/*创建储存特定序列的满二叉树*/\nvoid tree_create(int * a, int size) &#123;\n    if(size >= 1) &#123;\n        a[0] = 0;\n    &#125;\n    if(size >= 3) &#123;\n        a[1] = 0;\n        a[2] = 1;\n        /*当树的层数大于等于3时，树的左右节点呈对称排列*/\n        for(int i = 3; i &lt; size; i++) &#123;\n            if((i-3) % 4 == 0) a[i] = 0;\n            if((i-3) % 4 == 1) a[i] = 1;\n            if((i-3) % 4 == 2) a[i] = 1;\n            if((i-3) % 4 == 3) a[i] = 0;\n        &#125;\n    &#125;\n&#125;\n/*打印大小为size的数组到屏幕上*/\nint print(int * a, int size) &#123;\n    for(int i = 1; i &lt; size; i++) &#123;\n        printf(\"%d\", a[i]);\n    &#125;\n    printf(\"\\n\");\n&#125;\n/*使用DFS算法，对二叉树进行遍历，并用path数组记录路径*/\nvoid gray_create(int * a, int cur_place, int cur_len, int len, int * path) &#123;\n    path[cur_len] = a[cur_place];\n    if(cur_len == len) &#123; /*当现处的层数等于树叶所在的层数时，输出01串*/\n        print(path, len+1);\n        return;\n    &#125;\n    gray_create(a, (cur_place&lt;&lt;1) + 1, cur_len+1, len, path);\n    gray_create(a, (cur_place&lt;&lt;1) + 2, cur_len+1, len, path);\n&#125;\n\n/*创建01串 */\nvoid create(int * n) &#123;\n    if(input(n) == 1) &#123;\n        int len = *n;\n        int size = (1 &lt;&lt; (*n+1)) - 1;\n        int a[size];\n        int path[len+1];\n\n        tree_create(a, size);\n        gray_create(a, 0, 0, len, path);\n    &#125;\n&#125;\n\n\nint main() &#123;\n    int n;\n    create(&amp;n);\n    return 0;\n&#125;\n结果：\n\n","categories":["Program"],"tags":["C","DFS"]},{"title":"打印日历的C语言实现","url":"http://muo123.gitee.io/2021/03/10/calendar/","content":"打印日历的C语言实现实现nextDate函数，通过调用nextDate函数来打印出2021年的日历\n\nint nextDate(int month, int date, int year)\n  \n\n要求打印出指定日期的下一天，即给出某年某月某日，需返回下一天是多少号。具体代码如下：\n//***********************************************\n//*** a program to print the calendar of 2021 ***\n//***********************************************\n\n#include &lt;stdio.h>\n\n//this is a function to return the next date of the given day\nint nextDate(int month, int date, int year)&#123;\n\n    //use two arrays to store the days of leap year and common year\n    int leap_days[13] = &#123;0, 31, 29, 31, 30, 31, \n    30, 31, 31, 30, 31, 30, 31&#125;;\n    int common_days[13] = &#123;0, 31, 28, 31, 30, 31, \n    30, 31, 31, 30, 31, 30, 31&#125;;\n\n    //at first, decide wether it is a leap year\n    if((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0))&#123;\n        if(date + 1 > leap_days[month])&#123;\n    //if month is December, \n    //it means next day is the first day of new year\n            if(month == 12)&#123;\n                year++; month++; date = 1;\n            &#125; else&#123;\n                date++;\n            &#125;\n        &#125; else&#123;\n            date++;\n        &#125;\n    &#125; else&#123;\n        if(date + 1 > common_days[month])&#123;\n            if(month == 12)&#123;\n                year++; month++; date = 1;\n            &#125; else&#123;\n                date++;\n            &#125;\n        &#125; else&#123;\n            date++;\n        &#125;\n    &#125;\n    return date;\n&#125;\n\n\n//this is a function to print the calendar of 2021\nvoid printCalendar()&#123;\n    printf(\"\\n***********************************\\n\");\n    printf(\"* WELCOME TO THE CALENDAR OF 2021 *\\n\");\n    printf(\"***********************************\\n\\n\");\n\n    //the number of each month\n    int days[13] = &#123;0, 31, 28, 31, 30, 31, \n    30, 31, 31, 30, 31, 30, 31&#125;;  \n    //pointers of months'name\n    char* months[13] = &#123;\"fault\", \"January\", \"February\", \n    \"March\", \"April\", \"May\", \"June\", \"July\", \"August\",\n    \"September\", \"October\", \"November\", \"December\"&#125;;\n\n    for(int i = 1; i &lt;= 12; i++)&#123;\n        printf(\"***** %s *****\\n\", months[i]);\n        printf(\"Sun Mon Tue Wed Tus Fri Sat\\n\");\n\n        static int blanks = 5;   \n        //a variable to count the number of the blanks \n        for(int k = 0; k &lt; blanks; k++)&#123;\n            printf(\"    \");\n        &#125;\n\n        for(int j = 0; j &lt; days[i]; j++)&#123;\n            blanks++; \n\n            if(j &lt; 9)&#123;\n                printf(\"%d   \", nextDate(i, j, 2021)); \n                //print blanks to aline\n            &#125; else&#123;\n                printf(\"%d  \", nextDate(i, j, 2021));\n            &#125;\n            //this block is to decide whether to reprint the week\n            if(blanks == 7) &#123;\n                printf(\"\\n\");\n                blanks = 0;\n            &#125;\n        &#125;\n        printf(\"\\n\\n\");\n    &#125;\n&#125;\n\nint main()&#123;\n    printCalendar();\n    return 0;\n&#125;","categories":["Program"],"tags":["C"]},{"title":"灯塔和书","url":"http://muo123.gitee.io/2021/03/01/beacon&book/","content":"&ensp;&ensp;肤浅的语言和浅薄的思想，当我逐渐接受快餐般的生活后，所体会到的事物竟然会像湖面一样朴实无华，也如同湖底一样清澈见底。不知道从何时开始，自己的思想变得浅显易懂，当捧起书本仔细阅读后，才愈渐感受到自己无所适从的苍白和目空一切的自大。思想停滞的感觉就像是航行路上遇到礁石，阻滞不前的洋流将小船卷进了漩涡。数字媒体的飞速发展和信息流的铺天盖地，让很多人都暂时性的失去了认真思考的能力，显而易见，这不是一件值得赞颂的事情。\n&ensp;&ensp;很少有心去阅读书籍，所接受到的经验大多数来自口耳相传和媒体广播，所属于自己的能够舒畅表达自己观点的东西却越来越少。也许很多时候都会有人反驳说，能够表达观点的机会遍地都是，何必去惆怅这些不可捉摸的事物。我想说，不，我希望认清自己的立场和自己的观点，一味的附和只会沦为他人思想的奴隶，这是我所认为的另一种形式的愚昧。我很清楚自己在害怕，害怕变得肤浅，害怕变得不可理喻，害怕失去思考的能力。人类的诸多智慧都来源于会思考的脑袋，停止思考无异于自掘坟墓，至此也愈渐感受到这份沉重的压迫，这份压迫有关于知识，有关于思考，有关于发展，有关于未来。\n&ensp;&ensp;我清楚的明白信息社会的不可逆，也切身感受到信息所带来的福利与恩惠，但也体悟了信息所带来的负面情绪和消极影响。甄别信息的能力对每个人都是必不可少的，反之，轻易地堕落为信息的奴隶，最终成为不良媒体的口舌，将伪造的证据传播给无辜的未知群众，细思极恐。多读书，多思考，语言的表达非一日之功，知识的积累也非一朝一夕之事，对速成的渴望带来的是一时的愉悦和快感，但随之而来的是麻木的神经和苍白的语言，语无伦次地传达着其他人的知识，偶有成效但贻害自身。\n&ensp;&ensp;思考要向深处挖掘，就像树木汲取营养一般，知识的开花结果，是深邃的思想和优美的表达相结合的成果，不敢断定是否成效显著，但这是获得美味的精神食粮的开始。\n&ensp;&ensp;后记：“灯塔显得巍然屹立，远处的海岸线也静止不动。太阳热力渐增，大家聚集在一起，感到彼此的存在，对此他们几乎忘却了，麦卡利斯特的钓线垂直地落入海中”，之所以引用这段话，是因为以上内容都来源于阅读这段话时突然的感想。海和灯塔的画面在眼前闪烁，漫天星辰在远方升起，深邃的夜空下人们燃起了篝火，等待着潮起潮落。也许仅仅是自己太久未接触到书中所呈现的美景，才会突发此想吧，意识到自己贫乏的表达能力和浅薄的知识面，顿觉羞愧难当。\n","categories":["Idea"],"tags":[]},{"title":"互联网时代的热点领域与营销方法","url":"http://muo123.gitee.io/2021/01/06/net&sale&methods/","content":"热点领域5G5G 第五代移动通信技术（英语：5th generation mobile networks或5th generation wireless systems，简称5G）是最新一代移动通信技术，为4G（LTE-A、WiMAX-A）系统后的延伸。\n5G与4G相比，具有“更高网速、低延时高可靠、低功率海量连接”的特点。\n在超高速率方面，5G速率最高可以达到4G的100倍，实现10Gb/秒的峰值速率，能够用手机很流畅地看4K、8K高清视频，急速畅玩360度全景VR游戏等等。\n在超低时延方面，5G的空口时延可以低到1毫秒，仅相当于4G的十分之一，远高于人体的应激反应，可以广泛地应用于自动控制领域。\n在超大连接方面，5G每平方公里可以有100万的连接数，与4G相比用户容量可以大大增加，除了手机终端的连接之外，还可以广泛地应用于物联网。[1]\n5G时代，华为在技术和产品等多个维度实现全面领先，5G商用合同订单居首位且超半数位于欧洲市场。全球ICT行业权威咨询公司GlobalData发布的《5G接入网（RAN）竞争力分析报告》指出：前五大设备商中，华为在5GRAN（无线接入网）竞争力综合排名中位列第一，而其他设备商各有优劣，并列处于第二梯队。华为在基带容量、射频产品组合、部署简易度及技术演进能力这四个运营商看重的关键维度中均保持第一。\n云计算云计算（英语：cloud computing），也被意译为网络计算，是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机各种终端和其他设备，使用服务商提供的电脑基建作计算和资源。\n“云”一般具有相当的规模，一些知名的云供应商如Google云计算、Amazon、IBM、微软、阿里等也都拥能拥有上百万级的服务器规模。而依靠这些分布式的服务器所构建起来的“云”能够为使用者提供前所未有的计算能力。\n网络安全已经成为所有企业或个人创业者必须面对的问题，企业的IT团队或个人很难应对那些来自网络的恶意攻击，而使用云服务则可以借助更专业的安全团队来有效降低安全风险。\n人工智能AI人工智能（英语：artificial intelligence，缩写为AI）亦称智械、机器智能，指由人制造出来的机器所表现出来的智能。通常人工智能是指通过普通计算机程序来呈现人类智能的技术。\n人工智能历经三次发展浪潮：萌芽期、推理期，突破期、知识期，飞速发展期、机器学习期。目前，深度学习语音、图像识别领域大获成功。人工智能的迅速发展将深刻改变人类社会和世界的面貌，当前，不少国家已将人工智能上升为国家重大发展战略。\n近年来中国人工智能产业发展迅速。从市场规模来看，自2015年开始，中国人工智能市场规模逐年攀升。截至2017年中国人工智能市场规模已达到了217亿元，同比增长52.8%。据预测，到2020年，中国在人工智能的市场规模将达到710亿元。2015到2020年间复合年均增长率为44.5%。[3]\n物联网物联网（英语：Internet of Things，简称IoT）是一种计算设备、机械、数字机器相互关系的系统，具备通用唯一识别码（UID），并具有通过网络传输数据的能力，无需人与人、或是人与设备的交互。\n近年以来，随着互联网产业发展日趋成熟，产业链及基础生态环境相当完善，市场容量已趋饱和，物联网作为下一个风口，成为众多设备制造商、网络供应商、系统集成商看好的突破方向。十二五之后，国家对中国制造产业升级提出明确的改革口号，为整个行业得到国家的政策支持提供了有力保障。\n全球都将物联网视为信息技术的第三次浪潮，确立未来信息社会竞争优势的关键。据美国独立市场研究机构Forrester预测，物联网所带来的产业价值要比互联网高30倍，到2020年，中国物联网产业将经历应用创新、技术创新、服务创新三个关键的发展阶段，成长为一个超过五万亿规模的巨大市场。[4]\n营销方式病毒营销病毒营销（Viral Marketing，又称病毒式营销、病毒性营销 、基因营销或核爆式营销），是利用公众的积极性和人际网络，让营销信息像病毒一样传播和扩散，营销信息被快速复制传向数以万计、数以百万计的观众，它能够像病毒一样深入人脑，快速复制，迅速传播，将信息短时间内传向更多的受众。病毒营销是一种常见的网络营销方法，常用于进行网站推广、品牌推广等。\n大家了解的拼多多，就是忠实的病毒营销玩家，通过各种丰富的活动内容，促进用户进行分享裂变，实现有效传播。\n饥饿营销饥饿营销，运用于商品或服务的商业推广，是指商品提供者有意调低产量，以期达到调控供求关系、制造供不应求“假象”、以维护产品形象并维持商品较高售价和利润率的营销策略。\n当然，这种方法要适度，用得好可以使品牌形象得到提升，用得不好会引起用户的反感。比如咱们都知道小米手机，一度就曾饥饿营销过度。\n借势营销借势营销，是将销售的目的隐藏于营销活动之中，将产品的推广融入到一个消费者喜闻乐见的环境里，使消费者在这个环境中了解产品并接受产品的营销手段。\n具体表现为通过媒体争夺消费者眼球、借助消费者自身的传播力、依靠轻松娱乐的方式等潜移默化地引导市场消费。换言之，便是通过顺势、造势、借势等方式，以求提高企业或产品的知名度、美誉度，树立良好的品牌形象，并最终促成产品或服务销售的营销策略。\n但对于中国多如牛毛的企业来说，能很好的运用借势营销手段的人少之又少。很多企业在运用借势营销时，总是浪费资源、耗费精力而毫无所获。\n结语以上便是对互联网时代的热点领域和营销方法的简要介绍，感谢您的浏览\n","categories":["Idea"],"tags":[]},{"title":"大数据技术下新媒体用户画像与隐私安全","url":"http://muo123.gitee.io/2020/11/22/data&privacy/","content":"大数据技术下新媒体用户画像与隐私安全随着大数据时代的到来，各种用途的APP如雨后春笋般出现。例如用于外卖的美团、饿了么；用于社交通讯的QQ、微信；用于拍摄小视频的快手、抖音；用于购物的拼多多、淘宝……与此同时，用户画像的应用也越来越广泛，人们在感叹APP越来越懂用户的同时，也产生了担忧：大数据时代，各类APP在刻画用户画像的同时，用户的隐私安全如何得到保障？\n什么是用户画像简单来说，可以把用户画像理解为给用户贴标签。在新媒体时代，用户使用各种APP和社交媒体必然会遗留痕迹，而大数据就是将这些信息收集起来，然后对用户的年龄、社会属性、消费习惯、生活习惯等各个维度的信息进行分析、统计刻画出用户的画像。\n通过用户画像精准推送营销信息在大数据算法对不同用户进行了用户画像之后，在得知了用户真正的需求之后，各类 APP 就可以给用户精准提供用户所需商品。   \n用户在浏览淘宝时，对于自己喜爱的商品会加购或收藏，这些行为甚至在同一页面停留时间的长短都会成为用户画像构建的数据。当一位女性用户长期搜索婴儿用品时，大数据算法就可以推算出这位用户是一位母亲，并且需要的产品类型是婴儿用品。     \n抖音会根据用户观看视频的时长、类型、关注的人等数据对用户进行画像，以此完成个人专属推荐。比如有的用户喜欢看宠物视频，那么他在刷视频的过程中就会刷到很多关于宠物的视频推荐；而有的用户喜欢影视类视频，那这个用户就会被贴上“影视”的标签，所推荐的作品也会偏向于影视。    \n在 QQ、微博等社交平台上，用户经常会发现“可能认识的好友”这一标签，平台通过对用户关注、用户评论、用户点赞、共同好友等数据的收集，形成一个巨大的数据池，系统会通过智能推算出用户关系网，形成关系群，给用户的社交关系进行画像，然后进行智能化社交推荐。\n用户画像数据获取带来的隐私安全问题个人对自身信息的保护意识淡薄，是导致个人信息发生泄露重要原因之一。在很多情况下，人们会将自己个人信息共享给别人。比如在包括社交网站和电商购物平台在内的很多服务软件上注册会员时都需提供个人信息，在商家小利的优惠条件下，人们会愿意把自己的信息分享给别人。   \n部分商业公司在巨大的利益驱动下，不顾法律红线，开始从事贩卖个人信息的活动。这部分公司已经掌握了数据搜集技术，在未征得当事人许可的情况下就擅自对包含用户个人信息的数据进行搜集。并把这些搜集到的个人信息，进行分析、归类，然后转卖给诈骗团伙、广告运营商、中介公司等团体或个人，从而实现非法获利。    \n微信就曾因进行精准的广告投放，而被指控监控用户文字聊天数据，尽管微信已回应所有数据均已脱敏，但是仍然不能消除用户在使用时的担忧。除了腾讯，因为隐私泄露而被质疑的 APP 也不在少数。从阿里飞猪、携程、滴滴等一系列“大数据杀熟”行为，到美团、饿了么的“偷听门”风波，再到Facebook 大量用户信息泄露，这些 APP 似乎都被质疑“窥探用户隐私”。\n结语大数据技术已经到达一个相对成熟的阶段，而作为大数据技术根基的用户画像，不管是对企业的长远发展，还是对用户个性化服务的提供都具有十分重要的意义，但是用户画像在给人们生活带来遍历的同时也带来了隐私安全问题，这是互联网发展必须解决的问题。\n参考文献：[1]董莉莉.剖析大数据时代下用户画像及媒介策略[J]传媒,2016（2）：82-83.[2]徐 乐.数据时代隐私安全问题研究[D].成都理工大学，2016.6.[3]贾江洚,梁广洪.大数据时代下计算机网络信息安全问题探讨[J].计算机产品与流通,2019(11):52.\n","categories":["Idea"],"tags":[]},{"title":"Construct3制作射击小游戏（新手向）","url":"http://muo123.gitee.io/2020/10/04/construct3/","content":"Construct3制作射击小游戏（新手向）本教程将指导初学者制作一个简易的射击小游戏\n\n开始\n首先访问Construct3平台，点击相关链接editor.construct.net，即可在浏览器在线制作属于自己的小游戏，并不需要安装或设置相关文件，非常方便。\n\n创建新项目\n单击new project按钮,之后将出现对话框，直接点击create创建新项目即可，然后可以看到类似下面的新建项目。\n\n添加对象\n接下来添加游戏所需要的对象\n\n添加背景\n双击或右键点击空白处选择insert new object,找到Tiled Baekground后双击。此时鼠标会指向十字线，代表图像将要放置的位置，单击布局中间某处，打开图像编辑器。可以选择自己画背景或从文件中导入图片作为游戏的背景。关掉编辑器即可看到自己的背景图，然后右键点击Align选择Cover Layout即可将背景平铺到空白处。为了防止之后添加图像挪动背景，可以选择将背景Lock，右键单击可以看到相关选项。\n\n添加输入对象\n双击或右键打开菜单栏insert new object添加输入对象Mouse或Keyboard，以确保游戏接受鼠标或键盘输入。\n\n添加游戏对象\n按照类似添加背景的方式添加游戏对象：玩家、子弹、精灵以及爆炸图象。双击或右键打开菜单栏添加Sprites,并且分别为图像进行命名防止混淆。\n\n添加行为\n为玩家、子弹、精灵等对象添加行为以让他们按照我们想要的方式进行活动，平台提供的行为有多种选择\n单击对象，找到左边的菜单Behaviors添加行为的方式如下图所示玩家行为：8 direction(8方向移动)、ScorllTo（将镜头聚焦到玩家身上）、BoundToLayout（将玩家的活动范围固定防止移动到背景外）\n\n子弹行为：Bullet（子弹运动）、Destroy outside layout（销毁子弹防止移动到背景外）\n\n爆炸行为：Fade（爆炸对象出现时采用淡入淡出的动画形式）\n\n精灵行为：Bullet（方便系统控制精灵行为）\n\n事件\n首先，单击顶部的选项卡Event sheet1以切换到”事件工作表视图”。事件列表称为事件表 ，你可以为游戏的不同部分或组织使用不同的事件表。\n\n玩家活动\n让玩家按照你所想要的方式活动，例如让玩家视野跟随鼠标，事件如图：具体操作过程如下：\n让玩家能够发射子弹，事件如下：按照所述相关路径执行操作即可，这些不过多叙述。\n\n子弹活动\n\n\n精灵活动\n\n\n使用实例变量\n实例变量允许不同的对象拥有属于自己的属性，变量是可以更改的。我们可以对精灵添加一个实例变量health来让精灵拥有更长的生命值，而不是子弹一碰就发生爆炸。添加过程如图：我们可以设置条件，当子弹击中精灵时，扣除一定健康值，为游戏体验增加趣味性。将原来的事件进行修改如下：此时精灵经受多次射击才会发生爆炸。\n\n使用全局变量\n为了显示我们游戏的分数，需要一个全局变量来显示。右键单击事件工作表底部的空间，选择全局变量。修改之前的事件然后我们需要添加信新图层，用来显示我们的游戏分数。找到屏幕右下角的图层栏：右键单击选择Add layer at top,将名称改为HUD,然后在HUD的属性栏修改Parallax。之后我们需要添加一个文本对象，使用顶部的选项卡切换回布局视图，双击空白处添加文本对象Text,并将它放在左上角，你可以在它的属性栏里修改它的颜色，大小和位置等。最后回到工作事件表，添加事件：\n\n自动生成精灵\n为了让精灵持续出现，我们需要添加如下事件，让系统自动产生精灵。\n\n游戏结束条件\n此时，我们发现玩家是不会自动触发游戏结束的条件，所以我们还要添加事件，让玩家在碰到精灵时游戏结束，添加如下条件：\n\n至此，我们的游戏算是初步完成了，除了上面的事件外，我们还可以继续完善它，例如添加不同的精灵，让精灵随着时间逐渐加速、达到触发条件增加子弹数量等等。\n\n结束\n下面附上我的游戏链接和相关游戏视频：游戏链接：shooter  \n视频链接：shooter体验视频\n","categories":["Construct3"],"tags":[]},{"title":"关于Hexo+Gitee博客搭建时遇到的一些问题以及解决方案","url":"http://muo123.gitee.io/2020/09/13/hexo_fault/","content":"关于Hexo+Gitee博客搭建时遇到的一些问题以及解决方案localhost重定向次数过多对于这个问题，搜过很多方案，例如删除cookies，卸载浏览器重装，删除博客所有内容等，结果都以失败告终。出现这样的情况，可能是因为我每次建博客失败，删除文档重来时，一直使用的新建文件夹名称都是hexo，使用hexo s指令生成静态页面时，使得本地访问出现地址循环定向之类的问题（这只是我个人浅陋的想法，我对网页重定向也没有很深入的了解）。     \n我最后解决这个问题的方案是删除hexo文档，之后新建文档命名为blog，在blog目录下重新建立博客，再用hexo s指令生成网页，发现最后没有出现重定向次数过多的问题。    \n（ps：虽然删档重来的确很难受，我此前已经删档重来了不下十次，所以，这个解决方案对我来说还可以接受）\nGitee Pages部署失败（主题没有样式或使用hexo d指令无法推送博客内容）主题没有样式的问题，大概是本地生成网页正常，部署到Gitee Pages上后主题消失，页面回到十年前，简直降维打击的感觉。这个我也搜过许多解决方案，例如改变网站配置文件root的路径，将它改为“root: .”（这是指在当前目录搜索，没有样式的原因可能是网站搜索不到相关文件，打开网站检查可以看见一堆404）。不过，之后我发现，不用更改root也可以直接访问页面。当初样式消失的问题可能是当初我不小心修改了某些文件，如果按照教程来做的话，应该不会碰到相关问题。   \n无法推送博客的问题，比较难解释，我之前部署了公钥，总出现问题，后来我直接删除了公钥，结果还是存在问题。大概可以排除公钥的因素，不过，如果你想对仓库进行写入操作，公钥必须是个人公钥才行，否则部署时也会部署不上去。之后，我们来谈谈我是如何解决最终问题的。      \n最后我发现，问题出现在仓库名称上—xxx.gitee.io。这样命名的仓库名称是万恶的来源，具体原因和解决方案可以在Gitee Page原网页找到。具体是pages的二级目录的问题，只要把仓库名的后缀删去即可，这样就没有了相应配置文件的相对路径问题。     \n（注意，你的仓库名必须为你Gitee上的昵称。）\n","categories":["Hexo"],"tags":[]},{"title":"Hexo+Gitee博客搭建详细教程","url":"http://muo123.gitee.io/2020/09/13/hexo-create/","content":"Hexo+Gitee博客搭建详细教程Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown(或其他渲染引擎)解析文章，在几秒内，即可利用靓丽的主题生成静态网页。（节选自Hexo）\n\n一、环境配置\n\nGit\n安装过程详情可以参照以下博客《Windows系统Git安装教程（详解Git安装过程）》https://www.cnblogs.com/xueweisuoyong/p/11914045.html\n\n\nNodejs\n安装过程详情可以参照以下博客《windows系统下Node.js安装以及环境变量配置》https://www.cnblogs.com/hua-developer/p/12446235.html\n\n\n\n（注意，安装目录我使用的是D盘，大家可以按个人喜好选择，以下内容都以安装在D盘为例）\n\n二、Hexo的安装\n在D盘（之前所选择的安装目录下）右键Git Bash Here使用如下指令安装Hexo架构\n$ npm install hexo-cli -g\n或指定全局安装$ npm install -g hexo等待Hexo架构完成（大概几分钟）\n我们在Windows10平台使用Gitee+Hexo搭建博客前，需要先在本地建立一个用来存储个人博客的目录，例如可以选择在D盘新建文件夹blog。\n\n创建文件夹后，只需在blog目录下单击右键启动Git Bash Here,输入如下命令完成博客的初始化$ hexo init之后依次使用如下指令（依旧在上述端口中）$ hexo clean\n$ hexo generator #或者 hexo g\n$ hexo server #或者 hexo s然后就可以打开本地浏览器搜索http://localhost:4000，查看你的博客了。到此，博客算是完成了初步构建。\n\n三、*博客主题的下载和更换（选择性浏览）\nHexo默认的主题是landscape，如果你想更换主题可以尝试在Hexo主题界面下载themes\n\n具体操作流程如下\n搜索主题 -&gt; 点击主题（有的主题可能无法加载） -&gt; 复制网站链接 -&gt;在blog文件目录下找到theme文件夹 -&gt; 进入文件夹后右键打开Git Bash Here，输入如下指令$ git clone (将网站链接粘贴到此处)然后等待一段时间，你所心仪的主题便下好了。之后只需在blog目录下找到_config.yml文件，即网站配置文件。用vs code打开网站配置文件，找到theme一栏\n  \n将theme一栏改为你所下载的主题文件名即可。（此处我下载的是hexo-theme-Kaze主题，点击后可以查看kaze主题的相关安装及配置）\n\n四、Gitee的部署首先你需要注册Gitee的账号，接下来只需要新建独属于你的仓库，如图  \n新建仓库名为: (你的昵称)例如：muo123然后选择语言为HTML，仓库属性为共有public，其余可以不用管，之后点击创建，你就拥有了属于你自己的个性仓库了！    \n之后我们需要做的就是把本地的博客部署到Gitee上。首先，我们需要打开网站配置文件对这几项进行修改，我的配置如下repo为你的仓库名，可以在你的Gitee仓库处复制过来   \n完成这些布置后，只需在blog目录下右键Git Bash输入指令下载插件$ npm install hexo-deployer-git --save然后Gitee部署三连$ hexo clean\n$ hexo g\n$ hexo d然后你就会发现你的仓库中出现了blog的目录，\n\n接下来点击service（服务），便可以找到Gitee Pages，点击创建就可以看见你梦寐以求的博客啦。\n","categories":["Hexo"],"tags":[]}]