[{"title":"Homework of PPT9","url":"http://muo123.gitee.io/2020/11/03/h9/","content":"\nBubble Sort the list: 33, 56, 17, 8, 95, 22。Make sure the final result isfrom small to large.Write out the list after the 2nd pass. (10 points)实现程序如下图   #include &lt;stdio.h&gt;#include &lt;malloc.h&gt;typedef struct list &#123;\tint value;\tstruct list * next;&#125;list;void print_list(list * L) &#123; //function to print the list\tlist * temp = L-&gt;next;\twhile(temp != NULL) &#123;\t\tprintf(&quot;%d &quot;, temp-&gt;value);\t\ttemp = temp-&gt;next;\t&#125;&#125;void bubble_sort(list * L) &#123;\tint count = 0;  //count how many times bubble-sort has run\tint flag = 0;   //determine wether bubble-sort has finished\tfor(list * t1 = L-&gt;next; t1 != NULL; t1 = t1-&gt;next) &#123;\t\tfor(list * t2 = L-&gt;next; t2-&gt;next != NULL; t2 = t2-&gt;next) &#123;\t\t\tif(t2-&gt;value &gt; t2-&gt;next-&gt;value) &#123;\t\t\t\tint temp = t2-&gt;value;\t\t\t\tt2-&gt;value = t2-&gt;next-&gt;value;\t\t\t\tt2-&gt;next-&gt;value = temp;\t\t\t\tflag = 1;\t\t\t&#125;\t\t&#125;\t\tif(flag == 0) &#123;\t\t\treturn;\t\t&#125;\t\tprintf(&quot;the %d: &quot;, ++count);\t\tprint_list(L);\t\tprintf(&quot;\\n&quot;);\t\tflag = 0;\t&#125;&#125;int main() &#123;\tlist * L = (list *)malloc(sizeof(list));\tL-&gt;next = NULL;\tlist * temp = L;\tfor(int i = 0; i &lt; 6; i++) &#123;\t\tint value;\t\tscanf(&quot;%d&quot;, &amp;value);\t\tlist * new = (list *)malloc(sizeof(list));\t\tnew-&gt;value = value;\t\tnew-&gt;next = temp-&gt;next;\t\ttemp-&gt;next = new;\t\ttemp = new;\t&#125;\tbubble_sort(L);\tprintf(&quot;the final result: &quot;);\tprint_list(L);\treturn 0;&#125;//33 56 17 8 95 22\n最终测试如下图：于是，我们可以看出冒泡排序第二次执行后的链表为：17 8 33 22 56 95\n\n\nGive a sorted array as list={60,65,75,80,90,95}. Design an algorithm toinsert the value of x into the sorted array. Then test the algorithm withvalue 50,67,99.思考：为什么选择插入点在list头上、中间、尾巴上的三个数作为算法测试的数据，你能解释吗？算法如下\n取出第一个节点的值（第零个节点为head指针，里面没有内容）与要插入的值比较如果比插入值大，则在链表头执行插入操作否则，向后查找直到找到比插入值要大的节点，    若没有找到，则在链表尾执行插入操作    否则在该节点前一个位置执行插入操作\n\n选择插入点在list头上、中间、尾巴上的三个数作为算法测试的数据，能够涵盖插入的所有情况，具有代表性\n\n\nWhat is the state of the stack after the following sequence of Push andPop operations?   \nPush “anne”; Push “get”; Push “your” ; Pop; Push “my”; Push “gun”\n\n\n\n\n\n\n栈底\n—\n—\n栈顶\n\n\n\n\nanne\nget\nmy\ngun \n\n\n\n\n","categories":["homework"],"tags":[]},{"title":"硬件编程——机器指令编程","url":"http://muo123.gitee.io/2020/11/01/h7/","content":"实验报告\n\n\n\n实验名称\n姓名\n学号\n\n\n\n\n机器指令编程\n莫振威\n19335158\n\n\n\n\n实验目标\n理解冯·诺依曼计算机的结构\n理解机器指令的构成\n理解机器指令执行周期\n用汇编编写简单程序\n\n实验环境\nWindows7或以下,浏览器IE8或以下，Java RuntimeEnvironment1.6（JRE6.0）或以下\n\n实验步骤与结果启动Win7，使用IE8访问上述网址http://www.science.smith.edu/~jcardell/Courses/CSC103/CPUsim/cpusim.html,运行cpusim如下：\n任务1 ：简单程序\n打开网页 The PIPPIN User’s Guide,然后输入 Program 1：Add 2 number\n点击step after step，观察并回答下列问题：  \n\nPC、IR寄存器的作用：   \nPC寄存器负责储存内存地址，该地址指向下一条即将执行的指令，每解释执行完一条指令，pc寄存器的值就会自动被更新为下一条指令的地址   \nIR寄存器用来保存当前正在执行的一条指令。当执行一条指令时，先把它从内存取到数据寄存器（DR）中，然后再传送至IR   \n\nACC寄存器的全称和作用：   \nACC寄存器全称是累加器（Accumulator），是一个具有特殊用途的二进制8位寄存器，专门用来存放操作数或运算结果。\n\n用“LOD #3”指令的执行过程，解释Fetch-Execute周期：   \n通过PC寄存器获取下一条指令的地址，然后从存储器中取出对应指令放入IR寄存器中，IR寄存器将指令送去解码转换成机械码，识别操作数LOD，ALU运算单元进行运算，执行LOD指令，再把运算结果存放到ACC寄存器中，最后PC移到下一条指令地址\n\n\n用“ADD W”指令的执行过程，解释Fetch-Execute周期：   \n通过PC寄存器获取下一条指令的地址，然后从存储器中取出对应指令放入IR寄存器中，IR寄存器将指令送去解码转换成机械码，识别操作数ADD，ALU运算单元进行运算，执行LOD指令，再把运算结果存放到ACC寄存器中，最后PC移到下一条指令地址\n\n“LOD #3” 与 “ADD W” 指令的执行在Fetch-Execute周期级别，有什么不同：       \nLOD为单操作数指令，只需经过存储器一次取指令，ADD为双操作数指令，需要经过存储器两次取指令和操作数\n\n\n\n\n\n点击“Binary”,观察回答下面问题\n\n写出指令 “LOD #7” 的二进制形式，按指令结构，解释每部分的含义。   \n二进制形式：000 1 0100 00000111   \n含义：1-3位固定为0，4位为模式选择，1表示立即数，5-8位为指令内容，0100代表LOD指令，9-16为地址或立即数，00000111是立即数7。\n\n解释 RAM 的地址。   \nRAM的地址一般用十六进制表示，编号从0开始，每位地址可以存放八个二进制数字。\n\n该机器CPU是几位的？（按累加器的位数）8位\n\n写出该程序对应的 C语言表达。\nint w = 3;int x = 7;int y = x + w;\n\n\n\n\n任务2：简单循环\n输入程序Program 2，运行并回答问题：   \n用一句话总结程序的功能   将X初始化为3，每次循环减一到X=0\n写出对应的 c 语言程序int x = 3;do &#123;    x--;&#125; while(x != 0)\n\n\n修改该程序，用机器语言实现 10+9+8+..1 ，输出结果存放于内存 Y\n\n写出 c 语言的计算过程int x = 10;int y = 0;do &#123;    y += x;    x--;&#125; while(x != 0)\n写出机器语言的计算过程00010100 0000101000000101 1000000100010100 0000000000000101 1000001000000100 1000000100000000 1000001000000101 1000001000000100 1000000100010001 0000000100001101 0001100000000101 1000000100001100 0000100000001111 00000000\n用自己的语言，简单总结高级语言与机器语言的区别与联系。   \n\n区别：机器语言是计算机最原始的语言，是由0和1的代码构成，cpu在工作的时候只认识机器语言，即0和1的代码。高级语言是在低级语言的基础上，采用接近于人类自然语言的单词和符号来表示一组低级语言程序，使编程变得更加简单，易学，且写出的程序可读性强。\n联系：高级语言可以编译成机器语言，机器语言也可以用高级语言表述，两者能实现相同的作用。\n\n\n\n\n\n\n\n实验小结\n完成了任务1和任务2\n进一步理解了冯·诺依曼计算机的结构\n熟悉了机器指令的构成和机器指令执行周期\n初步掌握用汇编编写简单程序\n\n","categories":["homework"],"tags":[]},{"title":"Homework of PPT8-1&PPT8-2","url":"http://muo123.gitee.io/2020/11/01/h8/","content":"Homework of PPT8-1\n阅读 Pseudocode Standard。 \n 1） 用伪代码描述将十进制转换成16进制的方法:\n int num, flag &lt;- 0; &#x2F;*flag是负数标志位*&#x2F;char hex[maxsize];if num &lt; 0 then    flag &lt;- 1；    num &lt;- -num; &#x2F;*num为负数，将该信息储存*&#x2F;end ifdo &#123;    将num%16的值转换为字符hex[i]; &#x2F;*i的范围为[0, maxsize] *&#x2F;    num &lt;- num%16;&#125; while(num !&#x3D; 0)\n 2） C语言实现（先用注释写好算法，然后翻译）\n #include &lt;stdio.h&gt;#define maxsize 10char toChar(int n) &#123;  //将单个数字转化为16进制并且以字符形式返回 return n &lt; 10 ? n + &#x27;0&#x27; : &#x27;A&#x27; + n - 10;  &#125;int HexToDec(char * hex, int num) &#123;     //将10进制的数字（num&gt;0）转化为16进制的字符串， int i = 0;\t\t\t\t\t\t//并且返回字符串的长度 do &#123;  hex[i] = toChar(num % 16);  num /= 16;  i++; &#125; while(num != 0); return i;&#125;int main() &#123; int num;  char hex[maxsize]; scanf(&quot;%d&quot;, &amp;num); int flag = 0; //用来确定是否为负数的标志位 if(num &lt; 0) &#123; \tflag = 1; \tnum = -num;  //将num转化为正数进行数制转换 &#125; int size = HexToDec(hex, num); for(int i = size - 1; i &gt;= 0; i--) &#123; \tif(flag == 1) &#123;\t\t//当数字为负数时，将负号输出 \t\tprintf(&quot;-&quot;); \t&#125; \tprintf(&quot;%c&quot;, hex[i]); &#125; return 0;&#125;  \n 3） 使用 -1, 0, 1, 15, 26，3265 作为输入测试你的程序。 测试结果如下： \n\n名词解释与对比   \n 1） Top-down design : A top-down approach (also known as stepwise design and stepwise refinement and in some cases used as a synonym of decomposition) is essentially the breaking down of a system to gain insight into its compositional sub-systems in a reverse engineering fashion. 2）Work breakdown structure (WBS) : A work-breakdown structure (WBS) in project management and systems engineering, is a deliverable-oriented breakdown of a project into smaller components. 3）简述管理学 WBS 与 信息学Top-down设计 的异同:\n\n相同：都是化繁为简，化大为小的设计思路，核心思想都是分解。创建WBS是把项目工作按阶段可交付成果分解成较小的，更易于管理的组成部分的过程。按自顶向下的方法设计时,设计师首先对所设计的系统要有一个全面的理解.然后从顶层开始,连续地逐层向下分解,起到系统的所有模块都小到便于掌握为止。\n不同：WBS用于项目管理，top-down用于项目设计\n\n\n、仔细观察您洗衣机的运作过程，运用Top-down设计方法和Pseudocode 描述洗衣机控制程序。假设洗衣机可执行的基本操作如下：\nwater_in_switch(open_close) &#x2F;&#x2F; open 打开上水开关，close关闭water_out_switch(open_close) &#x2F;&#x2F; open 打开排水开关，close关闭get_water_volume() &#x2F;&#x2F;返回洗衣机内部水的高度motor_run(direction) &#x2F;&#x2F; 电机转动。left左转，right右转，stop停time_counter() &#x2F;&#x2F; 返回当前时间计数，以秒为单位halt(returncode) &#x2F;&#x2F;停机success 成功 failure 失败\n 1）请使用伪代码分解“正常洗衣”程序的大步骤。包括注水、浸泡等   \n water_in_switch(open）get_water_volume()water_in_switch(close)motorrun(left)motorrun(right)motorrun(stop)water_out_switch(open）get_water_volume()water_out_switch(close)\n 2）进一步用基本操作、控制语句（IF、FOR、WHILE等）、变量与表达式，写出每个步骤的伪代码    \n check wrongif success then\trecord time\twater_in_switch(open）\tget_water_volume()\tif enough then\t\ttimelimit\t\twater_in_switch(close)\t\tmotorrun(left)\t\tmotorrun(right)\t\tmotorrun(stop)\t\twater_out_switch    (open）\t\tget_water_volume()\t\tif empty then\t\t\twater_out_switch(close)\t\t\treturn time\t\t\tmusic        end if     end if end if \n 3）根据你的实践，请分析“正常洗衣”与“快速洗衣”在用户目标和程序上的异同。你认为是否存在改进（创新）空间，简单说明你的改进意见？  \n \n  用户目标：都是通过洗衣机洗衣便利生活。然而，快速洗衣所用时间短于正常洗衣，正常洗衣的清洁程度要优于快速洗衣   \n  程序上：两者执行程序步骤形同。然而，两者在程序步骤的时间摊销不同。   \n  改进意见：现实生活中，洗衣机存在多种模式，用户也有多种洗衣需求，应增加洗衣模式的多样化选择性。\n \n\n 4）通过步骤3），提取一些共性功能模块（函数），简化“正常洗衣”程序，使程序变得更利于人类理解和修改维护。例如：\n wait(time) &#x2F;&#x2F;等待指定的时间；注水(volume,timeout) &#x2F;&#x2F;在指定时间内完成注水，否则停机；排水(timeout)。 等子程序\n 改进：\n check wrongif success then    call 注水(volume,timeout)    call motorrun()    call 排水(timeout)    call 注水(volume，timeout)    call wait(time)    call 排水(timeout)    end if end if \n\n\nHomework of PPT8-2• 根据后面的素材，识别类和对象。阅读“牧师与恶魔过河”（http://www.17yy.com/f/69854.html) 的游戏介绍并玩游戏。然后回答问题– 游戏涉及哪些类。请列表说明 \n\n\n\n\n类\n人物类\n船类\n背景类\n河岸类\n河类\n\n\n\n\n\n\n\n\n\n– 游戏中有哪些对象，各几个。例如，船（一个）\n\n\n\n\n对象\n魔鬼\n牧师\n船\n河\n河岸\n背景\n\n\n\n\n数目\n3\n3\n1\n1\n2\n1   \n\n\n\n\n– 类和对象的区别是什么？举一个例子说明    \n\n 例如鼠标是一个类，而小明今天带的那个鼠标是一个对象。   \n 对象是对客观事物的抽象，类是对对象的抽象。类是一种抽象的数据类型。它们的关系是，对象是类的实例，类是对象的模板。\n    \n\n– 游戏中的魔鬼，有哪些属性和方法？      \n\n 属性：身份，位置坐标\n 方法：杀死牧师，上船，下船，渡河  \n    \n\n– 假设魔鬼被鼠标点中，会执行onclick事件，请用文字（伪代码）描述这个事件中魔鬼与其他对象沟通的过程。    \nif(devil is onclick)\n    if(devil is on the boat)\n        devil disembark\n    else\n        if the number of people on the boat &lt; 2\n        devil board teh ship\n– 类或对象会是动词吗   \n\n类和对象不会是动词。类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。现实中的实体用名词表示，而对象是类的实例，因此类和对象都应该用名词表示。\n","categories":["homework"],"tags":[]},{"title":"Homework of PPT6 and PPT7","url":"http://muo123.gitee.io/2020/10/14/h6(2)/","content":"<!-- \n\n    MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });\n -->\nHomework of PPT6\n\nAccording to the von Neumann architecture, List basic parts of a computer:   \n\n运算器、控制器、存储器、输入设备、输出设备 \n   \n\nA computer has 64 MB (megabytes) of memory. How many bits are needed to address any single byte in memory?     \n\n字长为4字节，主存容量为64MB/4=16M字，16M=$2^4*2^{20}$故存储器中对单个字节寻址共需要24位地址\n    \n\nList basic parts of a CPU, include cache or not?    \n\nCPU的基本组成部分是控制器和运算器，不包括高速缓冲存储器（Cache）。高速缓存存储器的主要作用是加快数据存取速度，从而加快CPU的运行速度；它是位于CPU与内存之间的临时存储器，它的容量比内存小但交换速度比内存快。\n目前高速缓存器也制作在CPU芯片内。\n     \n\nWhat mean secondary storage. List some on your PC.    \n\n辅助存储器一般指外存储器，是指除计算机内存及CPU缓存以外的储存器，此类储存器一般断电后仍然能保存数据。常见的外存储器有硬盘、软盘、光盘、U盘等。\n     \n\n使用维基百科，解释以下概念\n\nCPU : A central processing unit (CPU), also called a central processor, main processor or just processor, is the electronic circuitry within a computer that executes instructions that make up a computer program.    \n\nRAM : Random-access memory (RAM /ræm/) is a form of computer memory that can be read and changed in any order, typically used to store working data and machine code.     \n\nROM : Read-only memory (ROM) is a type of non-volatile memory used in computers and other electronic devices.      \n\nBus(computing) : In computer architecture, a bus[1] (a contraction of the Latin omnibus[citation needed], and historically also called data highway[2]) is a communication system that transfers data between components inside a computer, or between computers.    \n\nParallel Computing : Parallel computing is a type of computation where many calculations or the execution of processes are carried out simultaneously.     \n\n\n\n简单解释“云计算（Cloud Computing）”       \n\n云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。    \n\n\n\n\n\n小孙买了计算机主板，说明书表明“支持双通道DDR3-1333内存，最大支持16G”\nDDR3-1333内存,”3”和”1333”的含义： \nDDR3是指三代内存，1333是指默认工作频率是1333MHz\n小孙买8G DDR3-1600的内存是否能提高性能：\n能\n\n小孙买4G*2 DDR3-1333的内存能否提高性能：\n能\n\n16G需要多少位地址?16G = $2^4*2^30$,需要34位地址\n \n\n\n\nHomework of PPT7\n\nProgram with machine language according to the following c\nint_8 a = 1;int_8 c = a + 3;\n\nWrite your assembly code &amp; machine code : 汇编代码LOD #1STO a LOD aSTO cLOD cadd #3STO c\n机器代码00010100 0000000100000101 0000000000000100 0000000000000101 0010000000000100 0010000000010000 0000001100000101 00100000\nExplain machine code execution with the fetch-decode-execute cycle : \n机器周期的四个阶段通常分为两类：指令周期和执行周期。指令周期：1.提取：CPU根据PC生成存储器请求，从存储器中读取指令。2.解码：由指令解码器解码，将指令分解为不同的部分，以便在被CPU处理前可以容易理解它。执行周期：3.执行：处理当前获取的指令，识别指令格式所定义的操作码。4.存放：执行阶段计算出的结果将发送到内存或输出设备，PC更新以指向下一条指令。\n\nExplain functions about IR, PC, ACC registers in a CPU : \nIR（instruction register）用于暂存当前正在执行的指令PC（program counter）用来表示指令在主存中的地址ACC（accumulator）累加器，用来存放操作数或运算结果\nExplain physical meaning about vars a &amp; c in a machine :      a与c按位求与\n\n\n简答题\nWhat are stored in memory?\n内存里面存储的是操作系统和正在运行的应用程序需要的指令和数据。\n\nCan a data or a instruction stored in the same place?   \n数据和指令可以放在同一存储器\n \nExplain Instruction Format with example instructions.\n指令格式通常包括操作码和地址码，地址码的作用有指出操作数的地址、给出结果存放的地址和指出下一条指令的地址。例如四地址指令(参照MIPS指令的R格式指令):\n\n\n\n\n\n\n<!-- \ntable {\nmargin: auto;\n}\n -->\n\n\n\n\nop\nrs\nrt\nrd\nshamt\nfunct\n\n\n\n\n\n\n\n\n\n\n    OP是操作码，rs和rt是第一操作数和第二操作数,rd存放存放运算结果的地址，shamt是移位数，funct是扩展操作码。\n\n\n\n\n解释词汇\n汇编语言(Assembly Language) : In computer programming, assembly language (or assembler language),[1] often abbreviated asm, is any low-level programming language in which there is a very strong correspondence between the instructions in the language and the architecture’s machine code instructions.\n编译(Compiler) : In computing, a compiler is a computer program that translates computer code written in one programming language (the source language) into another language (the target language).\n命令式语言(Imperative programming) : In computer science, imperative programming is a programming paradigm that uses statements that change a program’s state. \n函数编程语言(Functional programming) :  In computer science, functional programming is a programming paradigm where programs are constructed by applying and composing functions.\n过程式编程(Procedural programming) : Procedural programming is a programming paradigm, derived from structured programming, based on the concept of the procedure call.\n\n\n\n","categories":["homework"],"tags":[]},{"title":"用电路做加法","url":"http://muo123.gitee.io/2020/10/14/h6/","content":"任务1：建立一个简单电路\n\n设计与门逻辑电路\n与门有多个输入，通过单刀双闸开关切换电路的不同输入状态\n为直观显示与门的输出，连接小灯泡观察亮灭以推测与门输出状态   \n设计电路后将相关元件连接\n对电路的输入输出进行测试，测试结果如图\n\n\n真值表验证与门功能\n选做题\n如何用XOR门作非门？将与非门的两个输入用导线相连\n\n\n\n任务2：验证电路等价\n\n分别建立电路A(B+C)和AB+AC在一个界面上。用A,B,C用三个开关控制输入，用两个LED表示输出\n分析后知道两者输入相同，故用三个电源与单刀双闸开关相连接，分别代表A，B，C三个输入信号\n电路A(B+C)和AB+AC的输出分别用两个独立的LED灯显示，将两者并联接入电路。\n按照电路设计将元件相连接\n测试结果如图：\n\n\n枚举所有可能输入，用真值表记录\n\n任务3：理解存储电路\n\n搭建S-Rlatch电路：\n顺序按Set、Reset，结果如下：\n\n任务4：设计全加器\n\n画出一位的全加电路\n画出二位的全加电路\n\n","categories":["homework"],"tags":[]},{"title":"第5周作业","url":"http://muo123.gitee.io/2020/10/07/h5/","content":"第5周作业\n\nPart 1\n\n与门的三种表现形式：与门是实现逻辑“乘”运算的电路，只有当所有输入端都是高电平（逻辑1）时，输出才为高电平。\n异或门的三种表现形式异或门是实现逻辑异或的逻辑门，只有当输入的两个电平相异，输出才为高电平。\n(A + B)(B + C)电路逻辑图如图\n真值表如下：    \n真值表如下：通过真值表可以知道该逻辑表达式逻辑等价\n\n\nPart 2\n\n电路图如下：\nFill the follow expression(1) $(X_8X_7X_6X_51111)_2$(2) $(X_8X_7X_6X_5X_4’X_3’X_2’X_1’)_2$(3) $(X_8X_7X_6X_5X_4’X_3’X_2’X_1’)_2$\n\n\nPart 3\n概念解释\nLogic gate : A logic gate is an idealized or physical electronic device implementing a Boolean function, a logical operation performed on one or more binary inputs that produces a single binary output.    \nBoolean algebra : In mathematics and mathematical logic, Boolean algebra is the branch of algebra in which the values of the variables are the truth values true and false, usually denoted 1 and 0, respectively.   \n\n存储电路\nFlip-flop中文翻译：触发器\nSR触发器只存储一个位信息0或1\n\n","categories":["homework"],"tags":[]},{"title":"Construct3制作射击小游戏（新手向）","url":"http://muo123.gitee.io/2020/10/04/test2/","content":"Construct3制作射击小游戏（新手向）本教程将指导初学者制作一个简易的射击小游戏\n\n开始\n首先访问Construct3平台，点击相关链接editor.construct.net，即可在浏览器在线制作属于自己的小游戏，并不需要安装或设置相关文件，非常方便。\n\n创建新项目\n单击new project按钮,之后将出现对话框，直接点击create创建新项目即可，然后可以看到类似下面的新建项目。\n\n添加对象\n接下来添加游戏所需要的对象\n\n添加背景\n双击或右键点击空白处选择insert new object,找到Tiled Baekground后双击。此时鼠标会指向十字线，代表图像将要放置的位置，单击布局中间某处，打开图像编辑器。可以选择自己画背景或从文件中导入图片作为游戏的背景。关掉编辑器即可看到自己的背景图，然后右键点击Align选择Cover Layout即可将背景平铺到空白处。为了防止之后添加图像挪动背景，可以选择将背景Lock，右键单击可以看到相关选项。\n\n添加输入对象\n双击或右键打开菜单栏insert new object添加输入对象Mouse或Keyboard，以确保游戏接受鼠标或键盘输入。\n\n添加游戏对象\n按照类似添加背景的方式添加游戏对象：玩家、子弹、精灵以及爆炸图象。双击或右键打开菜单栏添加Sprites,并且分别为图像进行命名防止混淆。\n\n添加行为\n为玩家、子弹、精灵等对象添加行为以让他们按照我们想要的方式进行活动，平台提供的行为有多种选择\n单击对象，找到左边的菜单Behaviors添加行为的方式如下图所示玩家行为：8 direction(8方向移动)、ScorllTo（将镜头聚焦到玩家身上）、BoundToLayout（将玩家的活动范围固定防止移动到背景外）子弹行为：Bullet（子弹运动）、Destroy outside layout（销毁子弹防止移动到背景外）爆炸行为：Fade（爆炸对象出现时采用淡入淡出的动画形式）精灵行为：Bullet（方便系统控制精灵行为）\n\n事件\n首先，单击顶部的选项卡Event sheet1以切换到”事件工作表视图”。事件列表称为事件表 ，你可以为游戏的不同部分或组织使用不同的事件表。\n\n玩家活动\n让玩家按照你所想要的方式活动，例如让玩家视野跟随鼠标，事件如图：具体操作过程如下：\n让玩家能够发射子弹，事件如下：按照所述相关路径执行操作即可，这些不过多叙述。\n\n子弹活动\n\n\n精灵活动\n\n\n使用实例变量\n实例变量允许不同的对象拥有属于自己的属性，变量是可以更改的。我们可以对精灵添加一个实例变量health来让精灵拥有更长的生命值，而不是子弹一碰就发生爆炸。添加过程如图：我们可以设置条件，当子弹击中精灵时，扣除一定健康值，为游戏体验增加趣味性。将原来的事件进行修改如下：此时精灵经受多次射击才会发生爆炸。\n\n使用全局变量\n为了显示我们游戏的分数，需要一个全局变量来显示。右键单击事件工作表底部的空间，选择全局变量。修改之前的事件然后我们需要添加信新图层，用来显示我们的游戏分数。找到屏幕右下角的图层栏：右键单击选择Add layer at top,将名称改为HUD,然后在HUD的属性栏修改Parallax。之后我们需要添加一个文本对象，使用顶部的选项卡切换回布局视图，双击空白处添加文本对象Text,并将它放在左上角，你可以在它的属性栏里修改它的颜色，大小和位置等。最后回到工作事件表，添加事件：\n\n自动生成精灵\n为了让精灵持续出现，我们需要添加如下事件，让系统自动产生精灵。\n\n游戏结束条件\n此时，我们发现玩家是不会自动触发游戏结束的条件，所以我们还要添加事件，让玩家在碰到精灵时游戏结束，添加如下条件：\n\n至此，我们的游戏算是初步完成了，除了上面的事件外，我们还可以继续完善它，例如添加不同的精灵，让精灵随着时间逐渐加速、达到触发条件增加子弹数量等等。\n\n结束\n下面附上我的游戏链接和相关游戏视频：游戏链接：shooter  \n视频链接：shooter体验视频\n","categories":[],"tags":["Tutorials"]},{"title":"第4周作业","url":"http://muo123.gitee.io/2020/09/26/h4/","content":"\n概念解释\n\nASCII : ASCII (/ˈæskiː/  ASS-kee), abbreviated from American Standard Code for Information Interchange, is a character encoding standard for electronic communication. ASCII codes represent text in computers, telecommunications equipment, and other devices. Most modern character-encoding schemes are based on ASCII, although they support many additional characters.   \n)Color : Color (American English), or colour (Commonwealth English), is the characteristic of visual perception described through color categories, with names such as red, orange, yellow, green, blue, or purple. This perception of color derives from the stimulation of photoreceptor cells (in particular cone cells in the human eye and other vertebrate eyes) by electromagnetic radiation (in the visible spectrum in the case of humans).    \n\n\n简答题\n   1) 写出字符“A”,“中”的 ASCII 码、Unicode 码、utf-8 编码。\n  \n\n\n    \n        \n            字符\n            ASCII 码\n            Unicode 码\n             utf-8 编码\n        \n    \n    \n        \n            \"A\"\n            0x41\n            0x0041\n            0x41\n        \n        \n            \"中\" \n            0xd6 / 0xd0\n            0x4e2d\n            0xe4 / 0xb8 / 0xad\n        \n    \n\n\n\n\n\n   1) 黄色(yellow)的RGB编码是\n(0, 255, 255)\n\n\n   3)  从网上下载一个 BMP 格式图像,用图片编辑工具另存在 jpg、 png、tiff 格式。问三种格式中,哪种格式显示质量好?相对于BMP 格式,压缩率各是多少?\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载图像不同格式显示对比如下：   \n\n \n\n\ntable th:first-of-type {\n    width: 200px;\n}\n\n\n\n    \n        \n            图片格式\n            占用空间\n            空间比较百分比（与原bmp格式）\n        \n    \n    \n        \n            bmp\n            458 KB (469,638 字节)\n            100%\n        \n        \n            jpg\n            71.4 KB (73,210 字节)\n            16%\n        \n        \n            png\n            261 KB (267,429 字节)\n            57%\n        \n        \n            tiff\n            458 KB (469,816 字节)\n            100%\n        \n    \n\n\n\n\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bmp格式经过在线图像压缩器onlineconvertfree转换为不同格式（jpg、png、tiff）后分辨率并没有明显变化，对比属性结果如下：\n\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过比较发现分辨率区别不是很大，但图片占用空间发生了变化   \nbmp &gt; tiff &gt; png &gt; jpg\n\n   1) Winrar压缩文件是lossless, or lossy 方法？    winrar是无损压缩，lossless\n\n","categories":["homework"],"tags":[]},{"title":"第3周作业","url":"http://muo123.gitee.io/2020/09/21/h3/","content":"\n\n计算\n\n1）x = 0100 0011 y = 1111 1001 z = 1011 01102）溢出3）x = 1101 00114）x = 0111 1111 y = 1111 1001 z溢出5）x = 1 . 0016）x = 11001 . 07）x出现精度误差\n\n概念解释\n-Method of complements : In mathematics and computing, the method of complements is a technique to encode a symmetric range of positive and negative integers in a way that they can use the same algorithm (hardware) for addition throughout the whole range.-Byte : The byte is a unit of digital information that most commonly consists of eight bits.-Integer (computer science)\n :  In computer science, an integer is a datum of integral data type, a data type that represents some range of mathematical integers.-Floating point : In computing, floating-point arithmetic (FP) is arithmetic using formulaic representation of real numbers as an approximation to support a trade-off between range and precision.\n阅读“Method of cpmplements”\n1) 假设运算使用n位二进制数，其模数为2n,数 a 为一个用n位二进制表示的常数，数 x 为一个用n位二进制表示的变数，推导如下：a - x = $2^n$ % $2^n$ + (a - x) % $2^n$ = ($2^n$ + (a - x)) % $2^n$ = (a + $2^n$ - x) % $2^n$ = a % $2^n$ + ($2^n$ - x) % $2^n$ = a + ($2^n$ - x)于是 x补码 = $2^n$ - x一个数的全部二进制位取反则得到其反码，由此可知，如果一个数加上它的反码，则此全部二进制位是满的，也就是全部是1，其值为x反码 + x = $2^{n-1}$ + $2^{n-2}$ + … + $2^2$ + $2^1$+ $2^0$ = $2^n$ – 1X反码 = $2^n$ - 1 - x综上可得 : X补码 = X反码 + 1 \n2) 用八进制描述变量x：x = 0361\n\n阅读“Two’s complement”\n1）x = 0xe1 y = 0xffffffe1过程：x = 1110 0001 -&gt; 符号扩展1111 1111 1111 1111 1111 1111 1110 0001 -&gt; y = x -&gt; y = 0xffffffe1\n阅读“Floating point”\n\n答：NaN（NotaNumber，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的是1985年的IEEE 754浮点数标准。\n","categories":["homework"],"tags":[]},{"title":"第2周作业","url":"http://muo123.gitee.io/2020/09/21/h2/","content":" 进制转换\n\n\n1分12秒  = (72000)毫秒\n(7A)13 =  (101)10\n(7A)16  =  (122)10\n(7A)16  = (1111010)2 = (172)8\n(1011011)2 = (133)8 = (5B)16\n(678)10  = (1010100110)2 = (1246)8\n(111)2 + (101)2 = (1100)2\n\n\n 关键词解释\n\n-Information   : Information can be thought of as the resolution of uncertainty; it is that which answers the question of \"What an entity is\" and thus defines both its essence and nature of its characteristics.   \n-Positional notation  : Positional notation (or place-value notation, or positional numeral system) denotes usually the extension to any base of the Hindu–Arabic numeral system (or decimal system).\n-Algorithm  :   In mathematics and computer science, an algorithm (/ˈælɡərɪðəm/ (About this soundlisten)) is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of problems or to perform a computation.\n-)Software bug  : A software bug is an error, flaw or fault in a computer program or system that causes it to produce an incorrect or unexpected result, or to behave in unintended ways.\n\n 英文单词\n\n\n十进制 -&gt;Decimal\n二进制  -&gt;Binary\n八进制   -&gt;Octal\n十六进制  -&gt;Hexadecimal\n\n","categories":["homework"],"tags":[]},{"title":"第1周作业","url":"http://muo123.gitee.io/2020/09/21/h1/","content":" 词条解释\n-Computer : A computer is a machine that can be instructed to carry out sequences of arithmetic or logical operations automatically via computer programming.\n-Computer science   : Computer science is the study of computation and information\n-Software  : Computer software, or simply software, is a collection of data or computer instructions that tell the computer how to work.\n-Software engineering  : Software engineering is the systematic application of engineering approaches to the development of software.[1][2][3] Software engineering is a computing discipline.\n- Alan Turing : Alan Mathison Turing OBE FRS (/ˈtjʊərɪŋ/; 23 June 1912 – 7 June 1954) was an English mathematician, computer scientist, logician, cryptanalyst, philosopher, and theoretical biologist.\n- Moore’s law : Moore’s law is the observation that the number of transistors in a dense integrated circuit (IC) doubles about every two years.\n","categories":["homework"],"tags":[]},{"title":"打印日历的C语言实现","url":"http://muo123.gitee.io/2020/09/14/calendar/","content":" 打印日历的C语言实现\n\n实现nextDate函数，通过调用nextDate函数来打印出2021年的日历    \nint nextDate(int month, int date, int year)\n要求打印出指定日期的下一天，即给出某年某月某日，需返回下一天是多少号。\n具体代码如下：\n\n//***********************************************\n//*** a program to print the calendar of 2021 ***\n//***********************************************\n\n#include &lt;stdio.h&gt;\n\n//this is a function to return the next date of the given day\nint nextDate(int month, int date, int year)&#123;\n    \n    //use two arrays to store the days of leap year and common year\n    int leap_days[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;\n    int common_days[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;\n    \n    //at first, decide wether it is a leap year\n    if((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0))&#123;\n        if(date + 1 &gt; leap_days[month])&#123;\n    //if month is December, it means next day is the first day of new year\n            if(month == 12)&#123;\n                year++; month++; date = 1;\n            &#125;\n            else&#123;\n                date++;\n            &#125;\n        &#125;\n        else&#123;\n            date++;\n        &#125;\n    &#125;\n    else&#123;\n        if(date + 1 &gt; common_days[month])&#123;\n            if(month == 12)&#123;\n                year++; month++; date = 1;\n            &#125;\n            else&#123;\n                date++;\n            &#125;\n        &#125;\n        else&#123;\n            date++;\n        &#125;\n    &#125;\n    return date;\n&#125;\n\n\n//this is a function to print the calendar of 2021\nvoid printCalendar()&#123;\n    printf(\"\\n***********************************\\n\");\n    printf(\"* WELCOME TO THE CALENDAR OF 2021 *\\n\");\n    printf(\"***********************************\\n\\n\");\n\n    //the number of each month\n    int days[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;  \n    //pointers of months'name\n    char* months[13] = &#123;\"fault\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"&#125;;\n\n    for(int i = 1; i &lt;= 12; i++)&#123;\n        printf(\"***** %s *****\\n\", months[i]);\n        printf(\"Sun Mon Tue Wed Tus Fri Sat\\n\");\n\n        static int blanks = 5;   //a variable to count the number of the blanks \n        for(int k = 0; k &lt; blanks; k++)&#123;\n            printf(\"    \");\n        &#125;\n\n        for(int j = 0; j &lt; days[i]; j++)&#123;\n            blanks++; \n\n            if(j &lt; 9)&#123;\n                printf(\"%d   \", nextDate(i, j, 2021)); //print blanks to aline\n            &#125;\n            else&#123;\n                printf(\"%d  \", nextDate(i, j, 2021));\n            &#125;\n            //this block is to decide whether to reprint the week\n            if(blanks == 7) &#123;\n                printf(\"\\n\");\n                blanks = 0;\n            &#125;\n        &#125;\n        printf(\"\\n\\n\");\n    &#125;\n&#125;\n\nint main()&#123;\n    printCalendar();\n    return 0;\n&#125;\n\n最后编译输出结果如下图：(截图显示部分输出结果)\n\n","categories":["Problem"],"tags":["Solution"]},{"title":"关于Hexo+Gitee博客搭建时遇到的一些问题以及解决方案","url":"http://muo123.gitee.io/2020/09/13/fault/","content":" 关于Hexo+Gitee博客搭建时遇到的一些问题以及解决方案\n\n\n localhost重定向次数过多\n\n\n对于这个问题，搜过很多方案，例如删除cookies，卸载浏览器重装，删除博客所有内容等，结果都以失败告终。\n出现这样的情况，可能是因为我每次建博客失败，删除文档重来时，一直使用的新建文件夹名称都是hexo，使用hexo s指令生成静态页面时，使得本地访问出现地址循环定向之类的问题（这只是我个人浅陋的想法，我对网页重定向也没有很深入的了解）。\n我最后解决这个问题的方案是删除hexo文档，之后新建文档命名为blog，在blog目录下重新建立博客，再用hexo s指令生成网页，发现最后没有出现重定向次数过多的问题。\n（ps：虽然删档重来的确很难受，我此前已经删档重来了不下十次，所以，这个解决方案对我来说还可以接受）\n\n\n\n Gitee Pages部署失败（主题没有样式或使用hexo d指令无法推送博客内容）\n\n\n主题没有样式的问题，大概是本地生成网页正常，部署到Gitee Pages上后主题消失，页面回到十年前，简直降维打击的感觉。这个我也搜过许多解决方案，例如改变网站配置文件root的路径，将它改为“root: .”（这是指在当前目录搜索，没有样式的原因可能是网站搜索不到相关文件，打开网站检查可以看见一堆404）。不过，之后我发现，不用更改root也可以直接访问页面。当初样式消失的问题可能是当初我不小心修改了某些文件，如果按照教程来做的话，应该不会碰到相关问题。\n无法推送博客的问题，比较难解释，我之前部署了公钥，总出现问题，后来我直接删除了公钥，结果还是存在问题。大概可以排除公钥的因素，不过，如果你想对仓库进行写入操作，公钥必须是个人公钥才行，否则部署时也会部署不上去。之后，我们来谈谈我是如何解决最终问题的。\n最后我发现，问题出现在仓库名称上--xxx.gitee.io。这样命名的仓库名称是万恶的来源，具体原因和解决方案可以在Gitee Page原网页找到。具体是pages的二级目录的问题，只要把仓库名的后缀删去即可，这样就没有了相应配置文件的相对路径问题。\n（注意，你的仓库名必须为你Gitee上的昵称。）\n","categories":["Hexo"],"tags":["Solution"]},{"title":"Hexo+Gitee博客搭建详细教程","url":"http://muo123.gitee.io/2020/09/13/test/","content":" Hexo+Gitee博客搭建详细教程\nHexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown(或其他渲染引擎)解析文章，在几秒内，即可利用靓丽的主题生成静态网页。（节选自Hexo）\n\n\n 一、环境配置\n\n\nGit\n\n\n安装过程详情可以参照以下博客《Windows系统Git安装教程（详解Git安装过程）》https://www.cnblogs.com/xueweisuoyong/p/11914045.html\n\n\nNodejs\n\n\n安装过程详情可以参照以下博客《windows系统下Node.js安装以及环境变量配置》https://www.cnblogs.com/hua-developer/p/12446235.html\n\n（注意，安装目录我使用的是D盘，大家可以按个人喜好选择，以下内容都以安装在D盘为例）\n\n\n 二、Hexo的安装\n\n在D盘（之前所选择的安装目录下）右键Git Bash Here使用如下指令安装Hexo架构\n$ npm install hexo-cli -g\n或指定全局安装\n$ npm install -g hexo\n等待Hexo架构完成（大概几分钟）\n我们在Windows10平台使用Gitee+Hexo搭建博客前，需要先在本地建立一个用来存储个人博客的目录，例如可以选择在D盘新建文件夹blog。\n\n创建文件夹后，只需在blog目录下单击右键启动Git Bash Here,输入如下命令完成博客的初始化\n$ hexo init\n之后依次使用如下指令（依旧在上述端口中）\n$ hexo clean$ hexo generator #或者 hexo g$ hexo server #或者 hexo s\n然后就可以打开本地浏览器搜索http://localhost:4000，查看你的博客了。到此，博客算是完成了初步构建。\n\n\n 三、*博客主题的下载和更换（选择性浏览）\n\nHexo默认的主题是landscape，如果你想更换主题可以尝试在Hexo主题界面下载themes\n\n 具体操作流程如下\n\n搜索主题 -&gt; 点击主题（有的主题可能无法加载） -&gt; 复制网站链接 -&gt;\n在blog文件目录下找到theme文件夹 -&gt; 进入文件夹后右键打开Git Bash Here，输入如下指令\n$ git clone (将网站链接粘贴到此处)\n然后等待一段时间，你所心仪的主题便下好了。之后只需在blog目录下找到_config.yml文件，即网站配置文件。用vs code打开网站配置文件，找到theme一栏\n\n将theme一栏改为你所下载的主题文件名即可。（此处我下载的是hexo-theme-Kaze主题，点击后可以查看kaze主题的相关安装及配置）\n\n\n 四、Gitee的部署\n首先你需要注册Gitee的账号，接下来只需要新建独属于你的仓库，如图\n\n新建仓库名为: (你的昵称)\n例如：muo123\n然后选择语言为HTML，仓库属性为共有public，其余可以不用管，之后点击创建，你就拥有了属于你自己的个性仓库了！\n之后我们需要做的就是把本地的博客部署到Gitee上。首先，我们需要打开网站配置文件\n\n对这几项进行修改，我的配置如下\n\nrepo为你的仓库名，可以在你的Gitee仓库处复制过来\n\n完成这些布置后，只需在blog目录下右键Git Bash输入指令下载插件\n$ npm install hexo-deployer-git --save\n然后Gitee部署三连\n$ hexo clean$ hexo g$ hexo d\n然后你就会发现你的仓库中出现了blog的目录，\n\n接下来点击service（服务），便可以找到Gitee Pages，点击创建就可以看见你梦寐以求的博客啦。\n","categories":["Hexo"],"tags":["Tutorials"]}]